#![allow(clippy::all)]
// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_OPERATOR_TYPE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_OPERATOR_TYPE: u8 = 115;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_OPERATOR_TYPE: [OperatorType; 116] = [
    OperatorType::Add,
    OperatorType::ArgMin,
    OperatorType::ArgMax,
    OperatorType::AveragePool,
    OperatorType::BatchNormalization,
    OperatorType::Cast,
    OperatorType::Clip,
    OperatorType::Concat,
    OperatorType::ConstantOfShape,
    OperatorType::Conv,
    OperatorType::ConvTranspose,
    OperatorType::Cos,
    OperatorType::CumSum,
    OperatorType::Div,
    OperatorType::Equal,
    OperatorType::Erf,
    OperatorType::Expand,
    OperatorType::Flatten,
    OperatorType::Gather,
    OperatorType::Gemm,
    OperatorType::GlobalAveragePool,
    OperatorType::Greater,
    OperatorType::GRU,
    OperatorType::Identity,
    OperatorType::LeakyRelu,
    OperatorType::Less,
    OperatorType::LessOrEqual,
    OperatorType::Log,
    OperatorType::LogSoftmax,
    OperatorType::LSTM,
    OperatorType::MatMul,
    OperatorType::MaxPool,
    OperatorType::Mod,
    OperatorType::Mul,
    OperatorType::Pad,
    OperatorType::Pow,
    OperatorType::Range,
    OperatorType::ReduceMean,
    OperatorType::ReduceL2,
    OperatorType::Relu,
    OperatorType::Reshape,
    OperatorType::Resize,
    OperatorType::Shape,
    OperatorType::Sigmoid,
    OperatorType::Sin,
    OperatorType::Slice,
    OperatorType::Split,
    OperatorType::Sqrt,
    OperatorType::Squeeze,
    OperatorType::Softmax,
    OperatorType::Sub,
    OperatorType::Tanh,
    OperatorType::Transpose,
    OperatorType::Unsqueeze,
    OperatorType::Where,
    OperatorType::ReduceProd,
    OperatorType::ReduceSum,
    OperatorType::ReduceMin,
    OperatorType::ReduceMax,
    OperatorType::NonZero,
    OperatorType::ScatterElements,
    OperatorType::Tile,
    OperatorType::Not,
    OperatorType::Abs,
    OperatorType::Max,
    OperatorType::Mean,
    OperatorType::Min,
    OperatorType::Sum,
    OperatorType::OneHot,
    OperatorType::Round,
    OperatorType::Floor,
    OperatorType::Ceil,
    OperatorType::Reciprocal,
    OperatorType::TopK,
    OperatorType::Neg,
    OperatorType::Exp,
    OperatorType::GreaterOrEqual,
    OperatorType::Size,
    OperatorType::Tan,
    OperatorType::Acos,
    OperatorType::Asin,
    OperatorType::Atan,
    OperatorType::InstanceNormalization,
    OperatorType::HardSigmoid,
    OperatorType::HardSwish,
    OperatorType::And,
    OperatorType::Or,
    OperatorType::Xor,
    OperatorType::Trilu,
    OperatorType::ScatterND,
    OperatorType::NonMaxSuppression,
    OperatorType::Sign,
    OperatorType::GatherElements,
    OperatorType::LayerNormalization,
    OperatorType::ReduceSumSquare,
    OperatorType::RandomUniform,
    OperatorType::Elu,
    OperatorType::RandomUniformLike,
    OperatorType::RandomNormal,
    OperatorType::RandomNormalLike,
    OperatorType::Softplus,
    OperatorType::GatherND,
    OperatorType::Gelu,
    OperatorType::Einsum,
    OperatorType::If,
    OperatorType::DequantizeLinear,
    OperatorType::QuantizeLinear,
    OperatorType::DynamicQuantizeLinear,
    OperatorType::MatMulInteger,
    OperatorType::DepthToSpace,
    OperatorType::ConvInteger,
    OperatorType::CastLike,
    OperatorType::Dropout,
    OperatorType::EyeLike,
    OperatorType::IsNaN,
    OperatorType::IsInf,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct OperatorType(pub u8);
#[allow(non_upper_case_globals)]
impl OperatorType {
    pub const Add: Self = Self(0);
    pub const ArgMin: Self = Self(1);
    pub const ArgMax: Self = Self(2);
    pub const AveragePool: Self = Self(3);
    pub const BatchNormalization: Self = Self(4);
    pub const Cast: Self = Self(5);
    pub const Clip: Self = Self(6);
    pub const Concat: Self = Self(7);
    pub const ConstantOfShape: Self = Self(8);
    pub const Conv: Self = Self(9);
    pub const ConvTranspose: Self = Self(10);
    pub const Cos: Self = Self(11);
    pub const CumSum: Self = Self(12);
    pub const Div: Self = Self(13);
    pub const Equal: Self = Self(14);
    pub const Erf: Self = Self(15);
    pub const Expand: Self = Self(16);
    pub const Flatten: Self = Self(17);
    pub const Gather: Self = Self(18);
    pub const Gemm: Self = Self(19);
    pub const GlobalAveragePool: Self = Self(20);
    pub const Greater: Self = Self(21);
    pub const GRU: Self = Self(22);
    pub const Identity: Self = Self(23);
    pub const LeakyRelu: Self = Self(24);
    pub const Less: Self = Self(25);
    pub const LessOrEqual: Self = Self(26);
    pub const Log: Self = Self(27);
    pub const LogSoftmax: Self = Self(28);
    pub const LSTM: Self = Self(29);
    pub const MatMul: Self = Self(30);
    pub const MaxPool: Self = Self(31);
    pub const Mod: Self = Self(32);
    pub const Mul: Self = Self(33);
    pub const Pad: Self = Self(34);
    pub const Pow: Self = Self(35);
    pub const Range: Self = Self(36);
    pub const ReduceMean: Self = Self(37);
    pub const ReduceL2: Self = Self(38);
    pub const Relu: Self = Self(39);
    pub const Reshape: Self = Self(40);
    pub const Resize: Self = Self(41);
    pub const Shape: Self = Self(42);
    pub const Sigmoid: Self = Self(43);
    pub const Sin: Self = Self(44);
    pub const Slice: Self = Self(45);
    pub const Split: Self = Self(46);
    pub const Sqrt: Self = Self(47);
    pub const Squeeze: Self = Self(48);
    pub const Softmax: Self = Self(49);
    pub const Sub: Self = Self(50);
    pub const Tanh: Self = Self(51);
    pub const Transpose: Self = Self(52);
    pub const Unsqueeze: Self = Self(53);
    pub const Where: Self = Self(54);
    pub const ReduceProd: Self = Self(55);
    pub const ReduceSum: Self = Self(56);
    pub const ReduceMin: Self = Self(57);
    pub const ReduceMax: Self = Self(58);
    pub const NonZero: Self = Self(59);
    pub const ScatterElements: Self = Self(60);
    pub const Tile: Self = Self(61);
    pub const Not: Self = Self(62);
    pub const Abs: Self = Self(63);
    pub const Max: Self = Self(64);
    pub const Mean: Self = Self(65);
    pub const Min: Self = Self(66);
    pub const Sum: Self = Self(67);
    pub const OneHot: Self = Self(68);
    pub const Round: Self = Self(69);
    pub const Floor: Self = Self(70);
    pub const Ceil: Self = Self(71);
    pub const Reciprocal: Self = Self(72);
    pub const TopK: Self = Self(73);
    pub const Neg: Self = Self(74);
    pub const Exp: Self = Self(75);
    pub const GreaterOrEqual: Self = Self(76);
    pub const Size: Self = Self(77);
    pub const Tan: Self = Self(78);
    pub const Acos: Self = Self(79);
    pub const Asin: Self = Self(80);
    pub const Atan: Self = Self(81);
    pub const InstanceNormalization: Self = Self(82);
    pub const HardSigmoid: Self = Self(83);
    pub const HardSwish: Self = Self(84);
    pub const And: Self = Self(85);
    pub const Or: Self = Self(86);
    pub const Xor: Self = Self(87);
    pub const Trilu: Self = Self(88);
    pub const ScatterND: Self = Self(89);
    pub const NonMaxSuppression: Self = Self(90);
    pub const Sign: Self = Self(91);
    pub const GatherElements: Self = Self(92);
    pub const LayerNormalization: Self = Self(93);
    pub const ReduceSumSquare: Self = Self(94);
    pub const RandomUniform: Self = Self(95);
    pub const Elu: Self = Self(96);
    pub const RandomUniformLike: Self = Self(97);
    pub const RandomNormal: Self = Self(98);
    pub const RandomNormalLike: Self = Self(99);
    pub const Softplus: Self = Self(100);
    pub const GatherND: Self = Self(101);
    pub const Gelu: Self = Self(102);
    pub const Einsum: Self = Self(103);
    pub const If: Self = Self(104);
    pub const DequantizeLinear: Self = Self(105);
    pub const QuantizeLinear: Self = Self(106);
    pub const DynamicQuantizeLinear: Self = Self(107);
    pub const MatMulInteger: Self = Self(108);
    pub const DepthToSpace: Self = Self(109);
    pub const ConvInteger: Self = Self(110);
    pub const CastLike: Self = Self(111);
    pub const Dropout: Self = Self(112);
    pub const EyeLike: Self = Self(113);
    pub const IsNaN: Self = Self(114);
    pub const IsInf: Self = Self(115);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 115;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::Add,
        Self::ArgMin,
        Self::ArgMax,
        Self::AveragePool,
        Self::BatchNormalization,
        Self::Cast,
        Self::Clip,
        Self::Concat,
        Self::ConstantOfShape,
        Self::Conv,
        Self::ConvTranspose,
        Self::Cos,
        Self::CumSum,
        Self::Div,
        Self::Equal,
        Self::Erf,
        Self::Expand,
        Self::Flatten,
        Self::Gather,
        Self::Gemm,
        Self::GlobalAveragePool,
        Self::Greater,
        Self::GRU,
        Self::Identity,
        Self::LeakyRelu,
        Self::Less,
        Self::LessOrEqual,
        Self::Log,
        Self::LogSoftmax,
        Self::LSTM,
        Self::MatMul,
        Self::MaxPool,
        Self::Mod,
        Self::Mul,
        Self::Pad,
        Self::Pow,
        Self::Range,
        Self::ReduceMean,
        Self::ReduceL2,
        Self::Relu,
        Self::Reshape,
        Self::Resize,
        Self::Shape,
        Self::Sigmoid,
        Self::Sin,
        Self::Slice,
        Self::Split,
        Self::Sqrt,
        Self::Squeeze,
        Self::Softmax,
        Self::Sub,
        Self::Tanh,
        Self::Transpose,
        Self::Unsqueeze,
        Self::Where,
        Self::ReduceProd,
        Self::ReduceSum,
        Self::ReduceMin,
        Self::ReduceMax,
        Self::NonZero,
        Self::ScatterElements,
        Self::Tile,
        Self::Not,
        Self::Abs,
        Self::Max,
        Self::Mean,
        Self::Min,
        Self::Sum,
        Self::OneHot,
        Self::Round,
        Self::Floor,
        Self::Ceil,
        Self::Reciprocal,
        Self::TopK,
        Self::Neg,
        Self::Exp,
        Self::GreaterOrEqual,
        Self::Size,
        Self::Tan,
        Self::Acos,
        Self::Asin,
        Self::Atan,
        Self::InstanceNormalization,
        Self::HardSigmoid,
        Self::HardSwish,
        Self::And,
        Self::Or,
        Self::Xor,
        Self::Trilu,
        Self::ScatterND,
        Self::NonMaxSuppression,
        Self::Sign,
        Self::GatherElements,
        Self::LayerNormalization,
        Self::ReduceSumSquare,
        Self::RandomUniform,
        Self::Elu,
        Self::RandomUniformLike,
        Self::RandomNormal,
        Self::RandomNormalLike,
        Self::Softplus,
        Self::GatherND,
        Self::Gelu,
        Self::Einsum,
        Self::If,
        Self::DequantizeLinear,
        Self::QuantizeLinear,
        Self::DynamicQuantizeLinear,
        Self::MatMulInteger,
        Self::DepthToSpace,
        Self::ConvInteger,
        Self::CastLike,
        Self::Dropout,
        Self::EyeLike,
        Self::IsNaN,
        Self::IsInf,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Add => Some("Add"),
            Self::ArgMin => Some("ArgMin"),
            Self::ArgMax => Some("ArgMax"),
            Self::AveragePool => Some("AveragePool"),
            Self::BatchNormalization => Some("BatchNormalization"),
            Self::Cast => Some("Cast"),
            Self::Clip => Some("Clip"),
            Self::Concat => Some("Concat"),
            Self::ConstantOfShape => Some("ConstantOfShape"),
            Self::Conv => Some("Conv"),
            Self::ConvTranspose => Some("ConvTranspose"),
            Self::Cos => Some("Cos"),
            Self::CumSum => Some("CumSum"),
            Self::Div => Some("Div"),
            Self::Equal => Some("Equal"),
            Self::Erf => Some("Erf"),
            Self::Expand => Some("Expand"),
            Self::Flatten => Some("Flatten"),
            Self::Gather => Some("Gather"),
            Self::Gemm => Some("Gemm"),
            Self::GlobalAveragePool => Some("GlobalAveragePool"),
            Self::Greater => Some("Greater"),
            Self::GRU => Some("GRU"),
            Self::Identity => Some("Identity"),
            Self::LeakyRelu => Some("LeakyRelu"),
            Self::Less => Some("Less"),
            Self::LessOrEqual => Some("LessOrEqual"),
            Self::Log => Some("Log"),
            Self::LogSoftmax => Some("LogSoftmax"),
            Self::LSTM => Some("LSTM"),
            Self::MatMul => Some("MatMul"),
            Self::MaxPool => Some("MaxPool"),
            Self::Mod => Some("Mod"),
            Self::Mul => Some("Mul"),
            Self::Pad => Some("Pad"),
            Self::Pow => Some("Pow"),
            Self::Range => Some("Range"),
            Self::ReduceMean => Some("ReduceMean"),
            Self::ReduceL2 => Some("ReduceL2"),
            Self::Relu => Some("Relu"),
            Self::Reshape => Some("Reshape"),
            Self::Resize => Some("Resize"),
            Self::Shape => Some("Shape"),
            Self::Sigmoid => Some("Sigmoid"),
            Self::Sin => Some("Sin"),
            Self::Slice => Some("Slice"),
            Self::Split => Some("Split"),
            Self::Sqrt => Some("Sqrt"),
            Self::Squeeze => Some("Squeeze"),
            Self::Softmax => Some("Softmax"),
            Self::Sub => Some("Sub"),
            Self::Tanh => Some("Tanh"),
            Self::Transpose => Some("Transpose"),
            Self::Unsqueeze => Some("Unsqueeze"),
            Self::Where => Some("Where"),
            Self::ReduceProd => Some("ReduceProd"),
            Self::ReduceSum => Some("ReduceSum"),
            Self::ReduceMin => Some("ReduceMin"),
            Self::ReduceMax => Some("ReduceMax"),
            Self::NonZero => Some("NonZero"),
            Self::ScatterElements => Some("ScatterElements"),
            Self::Tile => Some("Tile"),
            Self::Not => Some("Not"),
            Self::Abs => Some("Abs"),
            Self::Max => Some("Max"),
            Self::Mean => Some("Mean"),
            Self::Min => Some("Min"),
            Self::Sum => Some("Sum"),
            Self::OneHot => Some("OneHot"),
            Self::Round => Some("Round"),
            Self::Floor => Some("Floor"),
            Self::Ceil => Some("Ceil"),
            Self::Reciprocal => Some("Reciprocal"),
            Self::TopK => Some("TopK"),
            Self::Neg => Some("Neg"),
            Self::Exp => Some("Exp"),
            Self::GreaterOrEqual => Some("GreaterOrEqual"),
            Self::Size => Some("Size"),
            Self::Tan => Some("Tan"),
            Self::Acos => Some("Acos"),
            Self::Asin => Some("Asin"),
            Self::Atan => Some("Atan"),
            Self::InstanceNormalization => Some("InstanceNormalization"),
            Self::HardSigmoid => Some("HardSigmoid"),
            Self::HardSwish => Some("HardSwish"),
            Self::And => Some("And"),
            Self::Or => Some("Or"),
            Self::Xor => Some("Xor"),
            Self::Trilu => Some("Trilu"),
            Self::ScatterND => Some("ScatterND"),
            Self::NonMaxSuppression => Some("NonMaxSuppression"),
            Self::Sign => Some("Sign"),
            Self::GatherElements => Some("GatherElements"),
            Self::LayerNormalization => Some("LayerNormalization"),
            Self::ReduceSumSquare => Some("ReduceSumSquare"),
            Self::RandomUniform => Some("RandomUniform"),
            Self::Elu => Some("Elu"),
            Self::RandomUniformLike => Some("RandomUniformLike"),
            Self::RandomNormal => Some("RandomNormal"),
            Self::RandomNormalLike => Some("RandomNormalLike"),
            Self::Softplus => Some("Softplus"),
            Self::GatherND => Some("GatherND"),
            Self::Gelu => Some("Gelu"),
            Self::Einsum => Some("Einsum"),
            Self::If => Some("If"),
            Self::DequantizeLinear => Some("DequantizeLinear"),
            Self::QuantizeLinear => Some("QuantizeLinear"),
            Self::DynamicQuantizeLinear => Some("DynamicQuantizeLinear"),
            Self::MatMulInteger => Some("MatMulInteger"),
            Self::DepthToSpace => Some("DepthToSpace"),
            Self::ConvInteger => Some("ConvInteger"),
            Self::CastLike => Some("CastLike"),
            Self::Dropout => Some("Dropout"),
            Self::EyeLike => Some("EyeLike"),
            Self::IsNaN => Some("IsNaN"),
            Self::IsInf => Some("IsInf"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for OperatorType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for OperatorType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for OperatorType {
    type Output = OperatorType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for OperatorType {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for OperatorType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for OperatorType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_RNNDIRECTION: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_RNNDIRECTION: u8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RNNDIRECTION: [RNNDirection; 3] = [
    RNNDirection::Forward,
    RNNDirection::Reverse,
    RNNDirection::Bidirectional,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct RNNDirection(pub u8);
#[allow(non_upper_case_globals)]
impl RNNDirection {
    pub const Forward: Self = Self(0);
    pub const Reverse: Self = Self(1);
    pub const Bidirectional: Self = Self(2);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Forward, Self::Reverse, Self::Bidirectional];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Forward => Some("Forward"),
            Self::Reverse => Some("Reverse"),
            Self::Bidirectional => Some("Bidirectional"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for RNNDirection {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for RNNDirection {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for RNNDirection {
    type Output = RNNDirection;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for RNNDirection {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for RNNDirection {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for RNNDirection {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_AUTO_PAD: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_AUTO_PAD: u8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AUTO_PAD: [AutoPad; 2] = [AutoPad::Same, AutoPad::NotSet];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AutoPad(pub u8);
#[allow(non_upper_case_globals)]
impl AutoPad {
    pub const Same: Self = Self(0);
    pub const NotSet: Self = Self(1);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Same, Self::NotSet];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Same => Some("Same"),
            Self::NotSet => Some("NotSet"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for AutoPad {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for AutoPad {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for AutoPad {
    type Output = AutoPad;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AutoPad {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for AutoPad {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for AutoPad {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_DATA_TYPE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_DATA_TYPE: u8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATA_TYPE: [DataType; 4] = [
    DataType::Int32,
    DataType::Float,
    DataType::Int8,
    DataType::UInt8,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DataType(pub u8);
#[allow(non_upper_case_globals)]
impl DataType {
    pub const Int32: Self = Self(0);
    pub const Float: Self = Self(1);
    pub const Int8: Self = Self(2);
    pub const UInt8: Self = Self(3);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Int32, Self::Float, Self::Int8, Self::UInt8];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Int32 => Some("Int32"),
            Self::Float => Some("Float"),
            Self::Int8 => Some("Int8"),
            Self::UInt8 => Some("UInt8"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for DataType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for DataType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for DataType {
    type Output = DataType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DataType {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for DataType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for DataType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_COORD_TRANSFORM_MODE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_COORD_TRANSFORM_MODE: u8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COORD_TRANSFORM_MODE: [CoordTransformMode; 4] = [
    CoordTransformMode::HalfPixel,
    CoordTransformMode::Asymmetric,
    CoordTransformMode::AlignCorners,
    CoordTransformMode::PytorchHalfPixel,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CoordTransformMode(pub u8);
#[allow(non_upper_case_globals)]
impl CoordTransformMode {
    pub const HalfPixel: Self = Self(0);
    pub const Asymmetric: Self = Self(1);
    pub const AlignCorners: Self = Self(2);
    pub const PytorchHalfPixel: Self = Self(3);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::HalfPixel,
        Self::Asymmetric,
        Self::AlignCorners,
        Self::PytorchHalfPixel,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::HalfPixel => Some("HalfPixel"),
            Self::Asymmetric => Some("Asymmetric"),
            Self::AlignCorners => Some("AlignCorners"),
            Self::PytorchHalfPixel => Some("PytorchHalfPixel"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for CoordTransformMode {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for CoordTransformMode {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for CoordTransformMode {
    type Output = CoordTransformMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CoordTransformMode {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for CoordTransformMode {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for CoordTransformMode {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_NEAREST_MODE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_NEAREST_MODE: u8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_NEAREST_MODE: [NearestMode; 4] = [
    NearestMode::Floor,
    NearestMode::Ceil,
    NearestMode::RoundPreferFloor,
    NearestMode::RoundPreferCeil,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct NearestMode(pub u8);
#[allow(non_upper_case_globals)]
impl NearestMode {
    pub const Floor: Self = Self(0);
    pub const Ceil: Self = Self(1);
    pub const RoundPreferFloor: Self = Self(2);
    pub const RoundPreferCeil: Self = Self(3);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::Floor,
        Self::Ceil,
        Self::RoundPreferFloor,
        Self::RoundPreferCeil,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Floor => Some("Floor"),
            Self::Ceil => Some("Ceil"),
            Self::RoundPreferFloor => Some("RoundPreferFloor"),
            Self::RoundPreferCeil => Some("RoundPreferCeil"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for NearestMode {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for NearestMode {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for NearestMode {
    type Output = NearestMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for NearestMode {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for NearestMode {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for NearestMode {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_RESIZE_MODE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_RESIZE_MODE: u8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RESIZE_MODE: [ResizeMode; 2] = [ResizeMode::Nearest, ResizeMode::Linear];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ResizeMode(pub u8);
#[allow(non_upper_case_globals)]
impl ResizeMode {
    pub const Nearest: Self = Self(0);
    pub const Linear: Self = Self(1);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Nearest, Self::Linear];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Nearest => Some("Nearest"),
            Self::Linear => Some("Linear"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for ResizeMode {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for ResizeMode {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for ResizeMode {
    type Output = ResizeMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ResizeMode {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for ResizeMode {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for ResizeMode {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_OPERATOR_ATTRS: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_OPERATOR_ATTRS: u8 = 48;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_OPERATOR_ATTRS: [OperatorAttrs; 49] = [
    OperatorAttrs::NONE,
    OperatorAttrs::ArgMaxAttrs,
    OperatorAttrs::AveragePoolAttrs,
    OperatorAttrs::BatchNormalizationAttrs,
    OperatorAttrs::CastAttrs,
    OperatorAttrs::ConcatAttrs,
    OperatorAttrs::ConstantOfShapeAttrs,
    OperatorAttrs::ConvAttrs,
    OperatorAttrs::ConvTransposeAttrs,
    OperatorAttrs::FlattenAttrs,
    OperatorAttrs::GatherAttrs,
    OperatorAttrs::GemmAttrs,
    OperatorAttrs::GRUAttrs,
    OperatorAttrs::LeakyReluAttrs,
    OperatorAttrs::LSTMAttrs,
    OperatorAttrs::MaxPoolAttrs,
    OperatorAttrs::ReduceMeanAttrs,
    OperatorAttrs::ReshapeAttrs,
    OperatorAttrs::ResizeAttrs,
    OperatorAttrs::SplitAttrs,
    OperatorAttrs::SoftmaxAttrs,
    OperatorAttrs::TransposeAttrs,
    OperatorAttrs::ModAttrs,
    OperatorAttrs::ScatterElementsAttrs,
    OperatorAttrs::OneHotAttrs,
    OperatorAttrs::TopKAttrs,
    OperatorAttrs::HardSigmoidAttrs,
    OperatorAttrs::TriluAttrs,
    OperatorAttrs::ScatterNDAttrs,
    OperatorAttrs::NonMaxSuppressionAttrs,
    OperatorAttrs::LayerNormalizationAttrs,
    OperatorAttrs::RandomUniformAttrs,
    OperatorAttrs::EluAttrs,
    OperatorAttrs::RandomUniformLikeAttrs,
    OperatorAttrs::RandomNormalAttrs,
    OperatorAttrs::RandomNormalLikeAttrs,
    OperatorAttrs::GatherNDAttrs,
    OperatorAttrs::GeluAttrs,
    OperatorAttrs::EinsumAttrs,
    OperatorAttrs::IfAttrs,
    OperatorAttrs::PadAttrs,
    OperatorAttrs::DequantizeLinearAttrs,
    OperatorAttrs::QuantizeLinearAttrs,
    OperatorAttrs::DepthToSpaceAttrs,
    OperatorAttrs::CastLikeAttrs,
    OperatorAttrs::ShapeAttrs,
    OperatorAttrs::DropoutAttrs,
    OperatorAttrs::EyeLikeAttrs,
    OperatorAttrs::IsInfAttrs,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct OperatorAttrs(pub u8);
#[allow(non_upper_case_globals)]
impl OperatorAttrs {
    pub const NONE: Self = Self(0);
    pub const ArgMaxAttrs: Self = Self(1);
    pub const AveragePoolAttrs: Self = Self(2);
    pub const BatchNormalizationAttrs: Self = Self(3);
    pub const CastAttrs: Self = Self(4);
    pub const ConcatAttrs: Self = Self(5);
    pub const ConstantOfShapeAttrs: Self = Self(6);
    pub const ConvAttrs: Self = Self(7);
    pub const ConvTransposeAttrs: Self = Self(8);
    pub const FlattenAttrs: Self = Self(9);
    pub const GatherAttrs: Self = Self(10);
    pub const GemmAttrs: Self = Self(11);
    pub const GRUAttrs: Self = Self(12);
    pub const LeakyReluAttrs: Self = Self(13);
    pub const LSTMAttrs: Self = Self(14);
    pub const MaxPoolAttrs: Self = Self(15);
    pub const ReduceMeanAttrs: Self = Self(16);
    pub const ReshapeAttrs: Self = Self(17);
    pub const ResizeAttrs: Self = Self(18);
    pub const SplitAttrs: Self = Self(19);
    pub const SoftmaxAttrs: Self = Self(20);
    pub const TransposeAttrs: Self = Self(21);
    pub const ModAttrs: Self = Self(22);
    pub const ScatterElementsAttrs: Self = Self(23);
    pub const OneHotAttrs: Self = Self(24);
    pub const TopKAttrs: Self = Self(25);
    pub const HardSigmoidAttrs: Self = Self(26);
    pub const TriluAttrs: Self = Self(27);
    pub const ScatterNDAttrs: Self = Self(28);
    pub const NonMaxSuppressionAttrs: Self = Self(29);
    pub const LayerNormalizationAttrs: Self = Self(30);
    pub const RandomUniformAttrs: Self = Self(31);
    pub const EluAttrs: Self = Self(32);
    pub const RandomUniformLikeAttrs: Self = Self(33);
    pub const RandomNormalAttrs: Self = Self(34);
    pub const RandomNormalLikeAttrs: Self = Self(35);
    pub const GatherNDAttrs: Self = Self(36);
    pub const GeluAttrs: Self = Self(37);
    pub const EinsumAttrs: Self = Self(38);
    pub const IfAttrs: Self = Self(39);
    pub const PadAttrs: Self = Self(40);
    pub const DequantizeLinearAttrs: Self = Self(41);
    pub const QuantizeLinearAttrs: Self = Self(42);
    pub const DepthToSpaceAttrs: Self = Self(43);
    pub const CastLikeAttrs: Self = Self(44);
    pub const ShapeAttrs: Self = Self(45);
    pub const DropoutAttrs: Self = Self(46);
    pub const EyeLikeAttrs: Self = Self(47);
    pub const IsInfAttrs: Self = Self(48);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 48;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::ArgMaxAttrs,
        Self::AveragePoolAttrs,
        Self::BatchNormalizationAttrs,
        Self::CastAttrs,
        Self::ConcatAttrs,
        Self::ConstantOfShapeAttrs,
        Self::ConvAttrs,
        Self::ConvTransposeAttrs,
        Self::FlattenAttrs,
        Self::GatherAttrs,
        Self::GemmAttrs,
        Self::GRUAttrs,
        Self::LeakyReluAttrs,
        Self::LSTMAttrs,
        Self::MaxPoolAttrs,
        Self::ReduceMeanAttrs,
        Self::ReshapeAttrs,
        Self::ResizeAttrs,
        Self::SplitAttrs,
        Self::SoftmaxAttrs,
        Self::TransposeAttrs,
        Self::ModAttrs,
        Self::ScatterElementsAttrs,
        Self::OneHotAttrs,
        Self::TopKAttrs,
        Self::HardSigmoidAttrs,
        Self::TriluAttrs,
        Self::ScatterNDAttrs,
        Self::NonMaxSuppressionAttrs,
        Self::LayerNormalizationAttrs,
        Self::RandomUniformAttrs,
        Self::EluAttrs,
        Self::RandomUniformLikeAttrs,
        Self::RandomNormalAttrs,
        Self::RandomNormalLikeAttrs,
        Self::GatherNDAttrs,
        Self::GeluAttrs,
        Self::EinsumAttrs,
        Self::IfAttrs,
        Self::PadAttrs,
        Self::DequantizeLinearAttrs,
        Self::QuantizeLinearAttrs,
        Self::DepthToSpaceAttrs,
        Self::CastLikeAttrs,
        Self::ShapeAttrs,
        Self::DropoutAttrs,
        Self::EyeLikeAttrs,
        Self::IsInfAttrs,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ArgMaxAttrs => Some("ArgMaxAttrs"),
            Self::AveragePoolAttrs => Some("AveragePoolAttrs"),
            Self::BatchNormalizationAttrs => Some("BatchNormalizationAttrs"),
            Self::CastAttrs => Some("CastAttrs"),
            Self::ConcatAttrs => Some("ConcatAttrs"),
            Self::ConstantOfShapeAttrs => Some("ConstantOfShapeAttrs"),
            Self::ConvAttrs => Some("ConvAttrs"),
            Self::ConvTransposeAttrs => Some("ConvTransposeAttrs"),
            Self::FlattenAttrs => Some("FlattenAttrs"),
            Self::GatherAttrs => Some("GatherAttrs"),
            Self::GemmAttrs => Some("GemmAttrs"),
            Self::GRUAttrs => Some("GRUAttrs"),
            Self::LeakyReluAttrs => Some("LeakyReluAttrs"),
            Self::LSTMAttrs => Some("LSTMAttrs"),
            Self::MaxPoolAttrs => Some("MaxPoolAttrs"),
            Self::ReduceMeanAttrs => Some("ReduceMeanAttrs"),
            Self::ReshapeAttrs => Some("ReshapeAttrs"),
            Self::ResizeAttrs => Some("ResizeAttrs"),
            Self::SplitAttrs => Some("SplitAttrs"),
            Self::SoftmaxAttrs => Some("SoftmaxAttrs"),
            Self::TransposeAttrs => Some("TransposeAttrs"),
            Self::ModAttrs => Some("ModAttrs"),
            Self::ScatterElementsAttrs => Some("ScatterElementsAttrs"),
            Self::OneHotAttrs => Some("OneHotAttrs"),
            Self::TopKAttrs => Some("TopKAttrs"),
            Self::HardSigmoidAttrs => Some("HardSigmoidAttrs"),
            Self::TriluAttrs => Some("TriluAttrs"),
            Self::ScatterNDAttrs => Some("ScatterNDAttrs"),
            Self::NonMaxSuppressionAttrs => Some("NonMaxSuppressionAttrs"),
            Self::LayerNormalizationAttrs => Some("LayerNormalizationAttrs"),
            Self::RandomUniformAttrs => Some("RandomUniformAttrs"),
            Self::EluAttrs => Some("EluAttrs"),
            Self::RandomUniformLikeAttrs => Some("RandomUniformLikeAttrs"),
            Self::RandomNormalAttrs => Some("RandomNormalAttrs"),
            Self::RandomNormalLikeAttrs => Some("RandomNormalLikeAttrs"),
            Self::GatherNDAttrs => Some("GatherNDAttrs"),
            Self::GeluAttrs => Some("GeluAttrs"),
            Self::EinsumAttrs => Some("EinsumAttrs"),
            Self::IfAttrs => Some("IfAttrs"),
            Self::PadAttrs => Some("PadAttrs"),
            Self::DequantizeLinearAttrs => Some("DequantizeLinearAttrs"),
            Self::QuantizeLinearAttrs => Some("QuantizeLinearAttrs"),
            Self::DepthToSpaceAttrs => Some("DepthToSpaceAttrs"),
            Self::CastLikeAttrs => Some("CastLikeAttrs"),
            Self::ShapeAttrs => Some("ShapeAttrs"),
            Self::DropoutAttrs => Some("DropoutAttrs"),
            Self::EyeLikeAttrs => Some("EyeLikeAttrs"),
            Self::IsInfAttrs => Some("IsInfAttrs"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for OperatorAttrs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for OperatorAttrs {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for OperatorAttrs {
    type Output = OperatorAttrs;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for OperatorAttrs {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for OperatorAttrs {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for OperatorAttrs {}
pub struct OperatorAttrsUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_DEPTH_TO_SPACE_MODE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_DEPTH_TO_SPACE_MODE: u8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DEPTH_TO_SPACE_MODE: [DepthToSpaceMode; 2] =
    [DepthToSpaceMode::DCR, DepthToSpaceMode::CRD];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DepthToSpaceMode(pub u8);
#[allow(non_upper_case_globals)]
impl DepthToSpaceMode {
    pub const DCR: Self = Self(0);
    pub const CRD: Self = Self(1);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::DCR, Self::CRD];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::DCR => Some("DCR"),
            Self::CRD => Some("CRD"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for DepthToSpaceMode {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for DepthToSpaceMode {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for DepthToSpaceMode {
    type Output = DepthToSpaceMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DepthToSpaceMode {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for DepthToSpaceMode {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for DepthToSpaceMode {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_SCALAR: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_SCALAR: u8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SCALAR: [Scalar; 3] = [Scalar::NONE, Scalar::IntScalar, Scalar::FloatScalar];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Scalar(pub u8);
#[allow(non_upper_case_globals)]
impl Scalar {
    pub const NONE: Self = Self(0);
    pub const IntScalar: Self = Self(1);
    pub const FloatScalar: Self = Self(2);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::IntScalar, Self::FloatScalar];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::IntScalar => Some("IntScalar"),
            Self::FloatScalar => Some("FloatScalar"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for Scalar {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for Scalar {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for Scalar {
    type Output = Scalar;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Scalar {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for Scalar {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Scalar {}
pub struct ScalarUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_GELU_APPROXIMATION: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_GELU_APPROXIMATION: u8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GELU_APPROXIMATION: [GeluApproximation; 2] =
    [GeluApproximation::None, GeluApproximation::Tanh];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GeluApproximation(pub u8);
#[allow(non_upper_case_globals)]
impl GeluApproximation {
    pub const None: Self = Self(0);
    pub const Tanh: Self = Self(1);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::None, Self::Tanh];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::None => Some("None"),
            Self::Tanh => Some("Tanh"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for GeluApproximation {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for GeluApproximation {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for GeluApproximation {
    type Output = GeluApproximation;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GeluApproximation {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for GeluApproximation {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for GeluApproximation {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_NMSBOX_ORDER: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_NMSBOX_ORDER: u8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_NMSBOX_ORDER: [NMSBoxOrder; 2] = [
    NMSBoxOrder::TopLeftBottomRight,
    NMSBoxOrder::CenterWidthHeight,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct NMSBoxOrder(pub u8);
#[allow(non_upper_case_globals)]
impl NMSBoxOrder {
    pub const TopLeftBottomRight: Self = Self(0);
    pub const CenterWidthHeight: Self = Self(1);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::TopLeftBottomRight, Self::CenterWidthHeight];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::TopLeftBottomRight => Some("TopLeftBottomRight"),
            Self::CenterWidthHeight => Some("CenterWidthHeight"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for NMSBoxOrder {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for NMSBoxOrder {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for NMSBoxOrder {
    type Output = NMSBoxOrder;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for NMSBoxOrder {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for NMSBoxOrder {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for NMSBoxOrder {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_PAD_MODE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_PAD_MODE: u8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PAD_MODE: [PadMode; 4] = [
    PadMode::Constant,
    PadMode::Reflect,
    PadMode::Edge,
    PadMode::Wrap,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PadMode(pub u8);
#[allow(non_upper_case_globals)]
impl PadMode {
    pub const Constant: Self = Self(0);
    pub const Reflect: Self = Self(1);
    pub const Edge: Self = Self(2);
    pub const Wrap: Self = Self(3);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::Constant, Self::Reflect, Self::Edge, Self::Wrap];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Constant => Some("Constant"),
            Self::Reflect => Some("Reflect"),
            Self::Edge => Some("Edge"),
            Self::Wrap => Some("Wrap"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for PadMode {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for PadMode {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for PadMode {
    type Output = PadMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PadMode {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for PadMode {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for PadMode {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_SCATTER_REDUCTION: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_SCATTER_REDUCTION: u8 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SCATTER_REDUCTION: [ScatterReduction; 5] = [
    ScatterReduction::None,
    ScatterReduction::Add,
    ScatterReduction::Mul,
    ScatterReduction::Min,
    ScatterReduction::Max,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ScatterReduction(pub u8);
#[allow(non_upper_case_globals)]
impl ScatterReduction {
    pub const None: Self = Self(0);
    pub const Add: Self = Self(1);
    pub const Mul: Self = Self(2);
    pub const Min: Self = Self(3);
    pub const Max: Self = Self(4);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 4;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::None, Self::Add, Self::Mul, Self::Min, Self::Max];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::None => Some("None"),
            Self::Add => Some("Add"),
            Self::Mul => Some("Mul"),
            Self::Min => Some("Min"),
            Self::Max => Some("Max"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for ScatterReduction {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for ScatterReduction {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for ScatterReduction {
    type Output = ScatterReduction;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ScatterReduction {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for ScatterReduction {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for ScatterReduction {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_NODE_KIND: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_NODE_KIND: u8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_NODE_KIND: [NodeKind; 4] = [
    NodeKind::NONE,
    NodeKind::OperatorNode,
    NodeKind::ConstantNode,
    NodeKind::ValueNode,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct NodeKind(pub u8);
#[allow(non_upper_case_globals)]
impl NodeKind {
    pub const NONE: Self = Self(0);
    pub const OperatorNode: Self = Self(1);
    pub const ConstantNode: Self = Self(2);
    pub const ValueNode: Self = Self(3);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::OperatorNode,
        Self::ConstantNode,
        Self::ValueNode,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::OperatorNode => Some("OperatorNode"),
            Self::ConstantNode => Some("ConstantNode"),
            Self::ValueNode => Some("ValueNode"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for NodeKind {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for NodeKind {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for NodeKind {
    type Output = NodeKind;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for NodeKind {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for NodeKind {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for NodeKind {}
pub struct NodeKindUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_CONSTANT_DATA: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_CONSTANT_DATA: u8 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CONSTANT_DATA: [ConstantData; 5] = [
    ConstantData::NONE,
    ConstantData::FloatData,
    ConstantData::Int32Data,
    ConstantData::Int8Data,
    ConstantData::UInt8Data,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ConstantData(pub u8);
#[allow(non_upper_case_globals)]
impl ConstantData {
    pub const NONE: Self = Self(0);
    pub const FloatData: Self = Self(1);
    pub const Int32Data: Self = Self(2);
    pub const Int8Data: Self = Self(3);
    pub const UInt8Data: Self = Self(4);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::FloatData,
        Self::Int32Data,
        Self::Int8Data,
        Self::UInt8Data,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::FloatData => Some("FloatData"),
            Self::Int32Data => Some("Int32Data"),
            Self::Int8Data => Some("Int8Data"),
            Self::UInt8Data => Some("UInt8Data"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for ConstantData {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for ConstantData {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for ConstantData {
    type Output = ConstantData;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ConstantData {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for ConstantData {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for ConstantData {}
pub struct ConstantDataUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_CONSTANT_DATA_TYPE: u16 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_CONSTANT_DATA_TYPE: u16 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CONSTANT_DATA_TYPE: [ConstantDataType; 4] = [
    ConstantDataType::Int32,
    ConstantDataType::Float32,
    ConstantDataType::Int8,
    ConstantDataType::UInt8,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ConstantDataType(pub u16);
#[allow(non_upper_case_globals)]
impl ConstantDataType {
    pub const Int32: Self = Self(0);
    pub const Float32: Self = Self(1);
    pub const Int8: Self = Self(2);
    pub const UInt8: Self = Self(3);

    pub const ENUM_MIN: u16 = 0;
    pub const ENUM_MAX: u16 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Int32, Self::Float32, Self::Int8, Self::UInt8];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Int32 => Some("Int32"),
            Self::Float32 => Some("Float32"),
            Self::Int8 => Some("Int8"),
            Self::UInt8 => Some("UInt8"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for ConstantDataType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for ConstantDataType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u16>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for ConstantDataType {
    type Output = ConstantDataType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u16>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ConstantDataType {
    type Scalar = u16;
    #[inline]
    fn to_little_endian(self) -> u16 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u16) -> Self {
        let b = u16::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for ConstantDataType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u16::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for ConstantDataType {}
pub enum ArgMaxAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ArgMaxAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArgMaxAttrs<'a> {
    type Inner = ArgMaxAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ArgMaxAttrs<'a> {
    pub const VT_AXIS: flatbuffers::VOffsetT = 4;
    pub const VT_KEEP_DIMS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ArgMaxAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ArgMaxAttrsArgs,
    ) -> flatbuffers::WIPOffset<ArgMaxAttrs<'bldr>> {
        let mut builder = ArgMaxAttrsBuilder::new(_fbb);
        builder.add_axis(args.axis);
        builder.add_keep_dims(args.keep_dims);
        builder.finish()
    }

    #[inline]
    pub fn axis(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i32>(ArgMaxAttrs::VT_AXIS, Some(0)).unwrap() }
    }
    #[inline]
    pub fn keep_dims(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(ArgMaxAttrs::VT_KEEP_DIMS, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for ArgMaxAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("axis", Self::VT_AXIS, false)?
            .visit_field::<bool>("keep_dims", Self::VT_KEEP_DIMS, false)?
            .finish();
        Ok(())
    }
}
pub struct ArgMaxAttrsArgs {
    pub axis: i32,
    pub keep_dims: bool,
}
impl<'a> Default for ArgMaxAttrsArgs {
    #[inline]
    fn default() -> Self {
        ArgMaxAttrsArgs {
            axis: 0,
            keep_dims: false,
        }
    }
}

pub struct ArgMaxAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ArgMaxAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_axis(&mut self, axis: i32) {
        self.fbb_.push_slot::<i32>(ArgMaxAttrs::VT_AXIS, axis, 0);
    }
    #[inline]
    pub fn add_keep_dims(&mut self, keep_dims: bool) {
        self.fbb_
            .push_slot::<bool>(ArgMaxAttrs::VT_KEEP_DIMS, keep_dims, false);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ArgMaxAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ArgMaxAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ArgMaxAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ArgMaxAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ArgMaxAttrs");
        ds.field("axis", &self.axis());
        ds.field("keep_dims", &self.keep_dims());
        ds.finish()
    }
}
pub enum AveragePoolAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AveragePoolAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AveragePoolAttrs<'a> {
    type Inner = AveragePoolAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> AveragePoolAttrs<'a> {
    pub const VT_KERNEL_SIZE: flatbuffers::VOffsetT = 4;
    pub const VT_AUTO_PAD: flatbuffers::VOffsetT = 6;
    pub const VT_PADS: flatbuffers::VOffsetT = 8;
    pub const VT_STRIDES: flatbuffers::VOffsetT = 10;
    pub const VT_COUNT_INCLUDE_PAD: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AveragePoolAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args AveragePoolAttrsArgs<'args>,
    ) -> flatbuffers::WIPOffset<AveragePoolAttrs<'bldr>> {
        let mut builder = AveragePoolAttrsBuilder::new(_fbb);
        if let Some(x) = args.strides {
            builder.add_strides(x);
        }
        if let Some(x) = args.pads {
            builder.add_pads(x);
        }
        if let Some(x) = args.kernel_size {
            builder.add_kernel_size(x);
        }
        builder.add_count_include_pad(args.count_include_pad);
        builder.add_auto_pad(args.auto_pad);
        builder.finish()
    }

    #[inline]
    pub fn kernel_size(&self) -> flatbuffers::Vector<'a, u32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    AveragePoolAttrs::VT_KERNEL_SIZE,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn auto_pad(&self) -> AutoPad {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<AutoPad>(AveragePoolAttrs::VT_AUTO_PAD, Some(AutoPad::Same))
                .unwrap()
        }
    }
    #[inline]
    pub fn pads(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    AveragePoolAttrs::VT_PADS,
                    None,
                )
        }
    }
    #[inline]
    pub fn strides(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    AveragePoolAttrs::VT_STRIDES,
                    None,
                )
        }
    }
    #[inline]
    pub fn count_include_pad(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(AveragePoolAttrs::VT_COUNT_INCLUDE_PAD, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for AveragePoolAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "kernel_size",
                Self::VT_KERNEL_SIZE,
                true,
            )?
            .visit_field::<AutoPad>("auto_pad", Self::VT_AUTO_PAD, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "pads",
                Self::VT_PADS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "strides",
                Self::VT_STRIDES,
                false,
            )?
            .visit_field::<bool>("count_include_pad", Self::VT_COUNT_INCLUDE_PAD, false)?
            .finish();
        Ok(())
    }
}
pub struct AveragePoolAttrsArgs<'a> {
    pub kernel_size: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub auto_pad: AutoPad,
    pub pads: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub strides: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub count_include_pad: bool,
}
impl<'a> Default for AveragePoolAttrsArgs<'a> {
    #[inline]
    fn default() -> Self {
        AveragePoolAttrsArgs {
            kernel_size: None, // required field
            auto_pad: AutoPad::Same,
            pads: None,
            strides: None,
            count_include_pad: false,
        }
    }
}

pub struct AveragePoolAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AveragePoolAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_kernel_size(
        &mut self,
        kernel_size: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            AveragePoolAttrs::VT_KERNEL_SIZE,
            kernel_size,
        );
    }
    #[inline]
    pub fn add_auto_pad(&mut self, auto_pad: AutoPad) {
        self.fbb_
            .push_slot::<AutoPad>(AveragePoolAttrs::VT_AUTO_PAD, auto_pad, AutoPad::Same);
    }
    #[inline]
    pub fn add_pads(&mut self, pads: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(AveragePoolAttrs::VT_PADS, pads);
    }
    #[inline]
    pub fn add_strides(&mut self, strides: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(AveragePoolAttrs::VT_STRIDES, strides);
    }
    #[inline]
    pub fn add_count_include_pad(&mut self, count_include_pad: bool) {
        self.fbb_.push_slot::<bool>(
            AveragePoolAttrs::VT_COUNT_INCLUDE_PAD,
            count_include_pad,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> AveragePoolAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        AveragePoolAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<AveragePoolAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, AveragePoolAttrs::VT_KERNEL_SIZE, "kernel_size");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for AveragePoolAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("AveragePoolAttrs");
        ds.field("kernel_size", &self.kernel_size());
        ds.field("auto_pad", &self.auto_pad());
        ds.field("pads", &self.pads());
        ds.field("strides", &self.strides());
        ds.field("count_include_pad", &self.count_include_pad());
        ds.finish()
    }
}
pub enum BatchNormalizationAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BatchNormalizationAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BatchNormalizationAttrs<'a> {
    type Inner = BatchNormalizationAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> BatchNormalizationAttrs<'a> {
    pub const VT_EPSILON: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BatchNormalizationAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args BatchNormalizationAttrsArgs,
    ) -> flatbuffers::WIPOffset<BatchNormalizationAttrs<'bldr>> {
        let mut builder = BatchNormalizationAttrsBuilder::new(_fbb);
        builder.add_epsilon(args.epsilon);
        builder.finish()
    }

    #[inline]
    pub fn epsilon(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(BatchNormalizationAttrs::VT_EPSILON, Some(0.0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for BatchNormalizationAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("epsilon", Self::VT_EPSILON, false)?
            .finish();
        Ok(())
    }
}
pub struct BatchNormalizationAttrsArgs {
    pub epsilon: f32,
}
impl<'a> Default for BatchNormalizationAttrsArgs {
    #[inline]
    fn default() -> Self {
        BatchNormalizationAttrsArgs { epsilon: 0.0 }
    }
}

pub struct BatchNormalizationAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BatchNormalizationAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_epsilon(&mut self, epsilon: f32) {
        self.fbb_
            .push_slot::<f32>(BatchNormalizationAttrs::VT_EPSILON, epsilon, 0.0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> BatchNormalizationAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        BatchNormalizationAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<BatchNormalizationAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for BatchNormalizationAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("BatchNormalizationAttrs");
        ds.field("epsilon", &self.epsilon());
        ds.finish()
    }
}
pub enum CastAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CastAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CastAttrs<'a> {
    type Inner = CastAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> CastAttrs<'a> {
    pub const VT_TO: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CastAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args CastAttrsArgs,
    ) -> flatbuffers::WIPOffset<CastAttrs<'bldr>> {
        let mut builder = CastAttrsBuilder::new(_fbb);
        builder.add_to(args.to);
        builder.finish()
    }

    #[inline]
    pub fn to(&self) -> DataType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<DataType>(CastAttrs::VT_TO, Some(DataType::Int32))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for CastAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<DataType>("to", Self::VT_TO, false)?
            .finish();
        Ok(())
    }
}
pub struct CastAttrsArgs {
    pub to: DataType,
}
impl<'a> Default for CastAttrsArgs {
    #[inline]
    fn default() -> Self {
        CastAttrsArgs {
            to: DataType::Int32,
        }
    }
}

pub struct CastAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CastAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_to(&mut self, to: DataType) {
        self.fbb_
            .push_slot::<DataType>(CastAttrs::VT_TO, to, DataType::Int32);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CastAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        CastAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<CastAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for CastAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("CastAttrs");
        ds.field("to", &self.to());
        ds.finish()
    }
}
pub enum CastLikeAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CastLikeAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CastLikeAttrs<'a> {
    type Inner = CastLikeAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> CastLikeAttrs<'a> {
    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CastLikeAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        _args: &'args CastLikeAttrsArgs,
    ) -> flatbuffers::WIPOffset<CastLikeAttrs<'bldr>> {
        let mut builder = CastLikeAttrsBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for CastLikeAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct CastLikeAttrsArgs {}
impl<'a> Default for CastLikeAttrsArgs {
    #[inline]
    fn default() -> Self {
        CastLikeAttrsArgs {}
    }
}

pub struct CastLikeAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CastLikeAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> CastLikeAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        CastLikeAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<CastLikeAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for CastLikeAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("CastLikeAttrs");
        ds.finish()
    }
}
pub enum ConcatAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConcatAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConcatAttrs<'a> {
    type Inner = ConcatAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ConcatAttrs<'a> {
    pub const VT_AXIS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConcatAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ConcatAttrsArgs,
    ) -> flatbuffers::WIPOffset<ConcatAttrs<'bldr>> {
        let mut builder = ConcatAttrsBuilder::new(_fbb);
        builder.add_axis(args.axis);
        builder.finish()
    }

    #[inline]
    pub fn axis(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i32>(ConcatAttrs::VT_AXIS, Some(0)).unwrap() }
    }
}

impl flatbuffers::Verifiable for ConcatAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("axis", Self::VT_AXIS, false)?
            .finish();
        Ok(())
    }
}
pub struct ConcatAttrsArgs {
    pub axis: i32,
}
impl<'a> Default for ConcatAttrsArgs {
    #[inline]
    fn default() -> Self {
        ConcatAttrsArgs { axis: 0 }
    }
}

pub struct ConcatAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ConcatAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_axis(&mut self, axis: i32) {
        self.fbb_.push_slot::<i32>(ConcatAttrs::VT_AXIS, axis, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ConcatAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ConcatAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ConcatAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ConcatAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ConcatAttrs");
        ds.field("axis", &self.axis());
        ds.finish()
    }
}
pub enum DepthToSpaceAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DepthToSpaceAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DepthToSpaceAttrs<'a> {
    type Inner = DepthToSpaceAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> DepthToSpaceAttrs<'a> {
    pub const VT_MODE: flatbuffers::VOffsetT = 4;
    pub const VT_BLOCK_SIZE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DepthToSpaceAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args DepthToSpaceAttrsArgs,
    ) -> flatbuffers::WIPOffset<DepthToSpaceAttrs<'bldr>> {
        let mut builder = DepthToSpaceAttrsBuilder::new(_fbb);
        builder.add_block_size(args.block_size);
        builder.add_mode(args.mode);
        builder.finish()
    }

    #[inline]
    pub fn mode(&self) -> DepthToSpaceMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<DepthToSpaceMode>(DepthToSpaceAttrs::VT_MODE, Some(DepthToSpaceMode::DCR))
                .unwrap()
        }
    }
    #[inline]
    pub fn block_size(&self) -> u32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u32>(DepthToSpaceAttrs::VT_BLOCK_SIZE, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for DepthToSpaceAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<DepthToSpaceMode>("mode", Self::VT_MODE, false)?
            .visit_field::<u32>("block_size", Self::VT_BLOCK_SIZE, false)?
            .finish();
        Ok(())
    }
}
pub struct DepthToSpaceAttrsArgs {
    pub mode: DepthToSpaceMode,
    pub block_size: u32,
}
impl<'a> Default for DepthToSpaceAttrsArgs {
    #[inline]
    fn default() -> Self {
        DepthToSpaceAttrsArgs {
            mode: DepthToSpaceMode::DCR,
            block_size: 0,
        }
    }
}

pub struct DepthToSpaceAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DepthToSpaceAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_mode(&mut self, mode: DepthToSpaceMode) {
        self.fbb_.push_slot::<DepthToSpaceMode>(
            DepthToSpaceAttrs::VT_MODE,
            mode,
            DepthToSpaceMode::DCR,
        );
    }
    #[inline]
    pub fn add_block_size(&mut self, block_size: u32) {
        self.fbb_
            .push_slot::<u32>(DepthToSpaceAttrs::VT_BLOCK_SIZE, block_size, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> DepthToSpaceAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        DepthToSpaceAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DepthToSpaceAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for DepthToSpaceAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("DepthToSpaceAttrs");
        ds.field("mode", &self.mode());
        ds.field("block_size", &self.block_size());
        ds.finish()
    }
}
pub enum DropoutAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DropoutAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DropoutAttrs<'a> {
    type Inner = DropoutAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> DropoutAttrs<'a> {
    pub const VT_SEED: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DropoutAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args DropoutAttrsArgs,
    ) -> flatbuffers::WIPOffset<DropoutAttrs<'bldr>> {
        let mut builder = DropoutAttrsBuilder::new(_fbb);
        if let Some(x) = args.seed {
            builder.add_seed(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn seed(&self) -> Option<i32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i32>(DropoutAttrs::VT_SEED, None) }
    }
}

impl flatbuffers::Verifiable for DropoutAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("seed", Self::VT_SEED, false)?
            .finish();
        Ok(())
    }
}
pub struct DropoutAttrsArgs {
    pub seed: Option<i32>,
}
impl<'a> Default for DropoutAttrsArgs {
    #[inline]
    fn default() -> Self {
        DropoutAttrsArgs { seed: None }
    }
}

pub struct DropoutAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DropoutAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_seed(&mut self, seed: i32) {
        self.fbb_
            .push_slot_always::<i32>(DropoutAttrs::VT_SEED, seed);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> DropoutAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        DropoutAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DropoutAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for DropoutAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("DropoutAttrs");
        ds.field("seed", &self.seed());
        ds.finish()
    }
}
pub enum EyeLikeAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EyeLikeAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EyeLikeAttrs<'a> {
    type Inner = EyeLikeAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> EyeLikeAttrs<'a> {
    pub const VT_DTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_K: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EyeLikeAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args EyeLikeAttrsArgs,
    ) -> flatbuffers::WIPOffset<EyeLikeAttrs<'bldr>> {
        let mut builder = EyeLikeAttrsBuilder::new(_fbb);
        builder.add_k(args.k);
        if let Some(x) = args.dtype {
            builder.add_dtype(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn dtype(&self) -> Option<DataType> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<DataType>(EyeLikeAttrs::VT_DTYPE, None) }
    }
    #[inline]
    pub fn k(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i32>(EyeLikeAttrs::VT_K, Some(0)).unwrap() }
    }
}

impl flatbuffers::Verifiable for EyeLikeAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<DataType>("dtype", Self::VT_DTYPE, false)?
            .visit_field::<i32>("k", Self::VT_K, false)?
            .finish();
        Ok(())
    }
}
pub struct EyeLikeAttrsArgs {
    pub dtype: Option<DataType>,
    pub k: i32,
}
impl<'a> Default for EyeLikeAttrsArgs {
    #[inline]
    fn default() -> Self {
        EyeLikeAttrsArgs { dtype: None, k: 0 }
    }
}

pub struct EyeLikeAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EyeLikeAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_dtype(&mut self, dtype: DataType) {
        self.fbb_
            .push_slot_always::<DataType>(EyeLikeAttrs::VT_DTYPE, dtype);
    }
    #[inline]
    pub fn add_k(&mut self, k: i32) {
        self.fbb_.push_slot::<i32>(EyeLikeAttrs::VT_K, k, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> EyeLikeAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        EyeLikeAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EyeLikeAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for EyeLikeAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("EyeLikeAttrs");
        ds.field("dtype", &self.dtype());
        ds.field("k", &self.k());
        ds.finish()
    }
}
pub enum IsInfAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IsInfAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IsInfAttrs<'a> {
    type Inner = IsInfAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> IsInfAttrs<'a> {
    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IsInfAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        _args: &'args IsInfAttrsArgs,
    ) -> flatbuffers::WIPOffset<IsInfAttrs<'bldr>> {
        let mut builder = IsInfAttrsBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for IsInfAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct IsInfAttrsArgs {}
impl<'a> Default for IsInfAttrsArgs {
    #[inline]
    fn default() -> Self {
        IsInfAttrsArgs {}
    }
}

pub struct IsInfAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IsInfAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> IsInfAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        IsInfAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<IsInfAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for IsInfAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("IsInfAttrs");
        ds.finish()
    }
}
pub enum IntScalarOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IntScalar<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IntScalar<'a> {
    type Inner = IntScalar<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> IntScalar<'a> {
    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IntScalar { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args IntScalarArgs,
    ) -> flatbuffers::WIPOffset<IntScalar<'bldr>> {
        let mut builder = IntScalarBuilder::new(_fbb);
        builder.add_value(args.value);
        builder.finish()
    }

    #[inline]
    pub fn value(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i32>(IntScalar::VT_VALUE, Some(0)).unwrap() }
    }
}

impl flatbuffers::Verifiable for IntScalar<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct IntScalarArgs {
    pub value: i32,
}
impl<'a> Default for IntScalarArgs {
    #[inline]
    fn default() -> Self {
        IntScalarArgs { value: 0 }
    }
}

pub struct IntScalarBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IntScalarBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_value(&mut self, value: i32) {
        self.fbb_.push_slot::<i32>(IntScalar::VT_VALUE, value, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IntScalarBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        IntScalarBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<IntScalar<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for IntScalar<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("IntScalar");
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum FloatScalarOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FloatScalar<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FloatScalar<'a> {
    type Inner = FloatScalar<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> FloatScalar<'a> {
    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FloatScalar { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args FloatScalarArgs,
    ) -> flatbuffers::WIPOffset<FloatScalar<'bldr>> {
        let mut builder = FloatScalarBuilder::new(_fbb);
        builder.add_value(args.value);
        builder.finish()
    }

    #[inline]
    pub fn value(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(FloatScalar::VT_VALUE, Some(0.0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for FloatScalar<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct FloatScalarArgs {
    pub value: f32,
}
impl<'a> Default for FloatScalarArgs {
    #[inline]
    fn default() -> Self {
        FloatScalarArgs { value: 0.0 }
    }
}

pub struct FloatScalarBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FloatScalarBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_value(&mut self, value: f32) {
        self.fbb_
            .push_slot::<f32>(FloatScalar::VT_VALUE, value, 0.0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> FloatScalarBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        FloatScalarBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FloatScalar<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for FloatScalar<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("FloatScalar");
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum ConstantOfShapeAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConstantOfShapeAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConstantOfShapeAttrs<'a> {
    type Inner = ConstantOfShapeAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ConstantOfShapeAttrs<'a> {
    pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConstantOfShapeAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ConstantOfShapeAttrsArgs,
    ) -> flatbuffers::WIPOffset<ConstantOfShapeAttrs<'bldr>> {
        let mut builder = ConstantOfShapeAttrsBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_value_type(args.value_type);
        builder.finish()
    }

    #[inline]
    pub fn value_type(&self) -> Scalar {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<Scalar>(ConstantOfShapeAttrs::VT_VALUE_TYPE, Some(Scalar::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn value(&self) -> flatbuffers::Table<'a> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ConstantOfShapeAttrs::VT_VALUE,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_int_scalar(&self) -> Option<IntScalar<'a>> {
        if self.value_type() == Scalar::IntScalar {
            let u = self.value();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid union in this slot
            Some(unsafe { IntScalar::init_from_table(u) })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_float_scalar(&self) -> Option<FloatScalar<'a>> {
        if self.value_type() == Scalar::FloatScalar {
            let u = self.value();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid union in this slot
            Some(unsafe { FloatScalar::init_from_table(u) })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for ConstantOfShapeAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_union::<Scalar, _>(
                "value_type",
                Self::VT_VALUE_TYPE,
                "value",
                Self::VT_VALUE,
                true,
                |key, v, pos| match key {
                    Scalar::IntScalar => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<IntScalar>>(
                            "Scalar::IntScalar",
                            pos,
                        ),
                    Scalar::FloatScalar => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<FloatScalar>>(
                            "Scalar::FloatScalar",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct ConstantOfShapeAttrsArgs {
    pub value_type: Scalar,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ConstantOfShapeAttrsArgs {
    #[inline]
    fn default() -> Self {
        ConstantOfShapeAttrsArgs {
            value_type: Scalar::NONE,
            value: None, // required field
        }
    }
}

pub struct ConstantOfShapeAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ConstantOfShapeAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_value_type(&mut self, value_type: Scalar) {
        self.fbb_.push_slot::<Scalar>(
            ConstantOfShapeAttrs::VT_VALUE_TYPE,
            value_type,
            Scalar::NONE,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ConstantOfShapeAttrs::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ConstantOfShapeAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ConstantOfShapeAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ConstantOfShapeAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, ConstantOfShapeAttrs::VT_VALUE, "value");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ConstantOfShapeAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ConstantOfShapeAttrs");
        ds.field("value_type", &self.value_type());
        match self.value_type() {
            Scalar::IntScalar => {
                if let Some(x) = self.value_as_int_scalar() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            Scalar::FloatScalar => {
                if let Some(x) = self.value_as_float_scalar() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("value", &x)
            }
        };
        ds.finish()
    }
}
pub enum ConvAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConvAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConvAttrs<'a> {
    type Inner = ConvAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ConvAttrs<'a> {
    pub const VT_AUTO_PAD: flatbuffers::VOffsetT = 4;
    pub const VT_PADS: flatbuffers::VOffsetT = 6;
    pub const VT_GROUPS: flatbuffers::VOffsetT = 8;
    pub const VT_STRIDES: flatbuffers::VOffsetT = 10;
    pub const VT_DILATIONS: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConvAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ConvAttrsArgs<'args>,
    ) -> flatbuffers::WIPOffset<ConvAttrs<'bldr>> {
        let mut builder = ConvAttrsBuilder::new(_fbb);
        if let Some(x) = args.dilations {
            builder.add_dilations(x);
        }
        if let Some(x) = args.strides {
            builder.add_strides(x);
        }
        builder.add_groups(args.groups);
        if let Some(x) = args.pads {
            builder.add_pads(x);
        }
        builder.add_auto_pad(args.auto_pad);
        builder.finish()
    }

    #[inline]
    pub fn auto_pad(&self) -> AutoPad {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<AutoPad>(ConvAttrs::VT_AUTO_PAD, Some(AutoPad::Same))
                .unwrap()
        }
    }
    #[inline]
    pub fn pads(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    ConvAttrs::VT_PADS,
                    None,
                )
        }
    }
    #[inline]
    pub fn groups(&self) -> u32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u32>(ConvAttrs::VT_GROUPS, Some(0)).unwrap() }
    }
    #[inline]
    pub fn strides(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    ConvAttrs::VT_STRIDES,
                    None,
                )
        }
    }
    #[inline]
    pub fn dilations(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    ConvAttrs::VT_DILATIONS,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for ConvAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<AutoPad>("auto_pad", Self::VT_AUTO_PAD, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "pads",
                Self::VT_PADS,
                false,
            )?
            .visit_field::<u32>("groups", Self::VT_GROUPS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "strides",
                Self::VT_STRIDES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "dilations",
                Self::VT_DILATIONS,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ConvAttrsArgs<'a> {
    pub auto_pad: AutoPad,
    pub pads: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub groups: u32,
    pub strides: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub dilations: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for ConvAttrsArgs<'a> {
    #[inline]
    fn default() -> Self {
        ConvAttrsArgs {
            auto_pad: AutoPad::Same,
            pads: None,
            groups: 0,
            strides: None,
            dilations: None,
        }
    }
}

pub struct ConvAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ConvAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_auto_pad(&mut self, auto_pad: AutoPad) {
        self.fbb_
            .push_slot::<AutoPad>(ConvAttrs::VT_AUTO_PAD, auto_pad, AutoPad::Same);
    }
    #[inline]
    pub fn add_pads(&mut self, pads: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ConvAttrs::VT_PADS, pads);
    }
    #[inline]
    pub fn add_groups(&mut self, groups: u32) {
        self.fbb_.push_slot::<u32>(ConvAttrs::VT_GROUPS, groups, 0);
    }
    #[inline]
    pub fn add_strides(&mut self, strides: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ConvAttrs::VT_STRIDES, strides);
    }
    #[inline]
    pub fn add_dilations(
        &mut self,
        dilations: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ConvAttrs::VT_DILATIONS, dilations);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ConvAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ConvAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ConvAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ConvAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ConvAttrs");
        ds.field("auto_pad", &self.auto_pad());
        ds.field("pads", &self.pads());
        ds.field("groups", &self.groups());
        ds.field("strides", &self.strides());
        ds.field("dilations", &self.dilations());
        ds.finish()
    }
}
pub enum ConvTransposeAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConvTransposeAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConvTransposeAttrs<'a> {
    type Inner = ConvTransposeAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ConvTransposeAttrs<'a> {
    pub const VT_STRIDES: flatbuffers::VOffsetT = 4;
    pub const VT_AUTO_PAD: flatbuffers::VOffsetT = 6;
    pub const VT_PADS: flatbuffers::VOffsetT = 8;
    pub const VT_GROUPS: flatbuffers::VOffsetT = 10;
    pub const VT_OUTPUT_PADDING: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConvTransposeAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ConvTransposeAttrsArgs<'args>,
    ) -> flatbuffers::WIPOffset<ConvTransposeAttrs<'bldr>> {
        let mut builder = ConvTransposeAttrsBuilder::new(_fbb);
        if let Some(x) = args.output_padding {
            builder.add_output_padding(x);
        }
        builder.add_groups(args.groups);
        if let Some(x) = args.pads {
            builder.add_pads(x);
        }
        if let Some(x) = args.strides {
            builder.add_strides(x);
        }
        builder.add_auto_pad(args.auto_pad);
        builder.finish()
    }

    #[inline]
    pub fn strides(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    ConvTransposeAttrs::VT_STRIDES,
                    None,
                )
        }
    }
    #[inline]
    pub fn auto_pad(&self) -> AutoPad {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<AutoPad>(ConvTransposeAttrs::VT_AUTO_PAD, Some(AutoPad::NotSet))
                .unwrap()
        }
    }
    #[inline]
    pub fn pads(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    ConvTransposeAttrs::VT_PADS,
                    None,
                )
        }
    }
    #[inline]
    pub fn groups(&self) -> u32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u32>(ConvTransposeAttrs::VT_GROUPS, Some(1))
                .unwrap()
        }
    }
    #[inline]
    pub fn output_padding(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    ConvTransposeAttrs::VT_OUTPUT_PADDING,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for ConvTransposeAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "strides",
                Self::VT_STRIDES,
                false,
            )?
            .visit_field::<AutoPad>("auto_pad", Self::VT_AUTO_PAD, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "pads",
                Self::VT_PADS,
                false,
            )?
            .visit_field::<u32>("groups", Self::VT_GROUPS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "output_padding",
                Self::VT_OUTPUT_PADDING,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ConvTransposeAttrsArgs<'a> {
    pub strides: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub auto_pad: AutoPad,
    pub pads: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub groups: u32,
    pub output_padding: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for ConvTransposeAttrsArgs<'a> {
    #[inline]
    fn default() -> Self {
        ConvTransposeAttrsArgs {
            strides: None,
            auto_pad: AutoPad::NotSet,
            pads: None,
            groups: 1,
            output_padding: None,
        }
    }
}

pub struct ConvTransposeAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ConvTransposeAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_strides(&mut self, strides: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ConvTransposeAttrs::VT_STRIDES, strides);
    }
    #[inline]
    pub fn add_auto_pad(&mut self, auto_pad: AutoPad) {
        self.fbb_
            .push_slot::<AutoPad>(ConvTransposeAttrs::VT_AUTO_PAD, auto_pad, AutoPad::NotSet);
    }
    #[inline]
    pub fn add_pads(&mut self, pads: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ConvTransposeAttrs::VT_PADS, pads);
    }
    #[inline]
    pub fn add_groups(&mut self, groups: u32) {
        self.fbb_
            .push_slot::<u32>(ConvTransposeAttrs::VT_GROUPS, groups, 1);
    }
    #[inline]
    pub fn add_output_padding(
        &mut self,
        output_padding: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ConvTransposeAttrs::VT_OUTPUT_PADDING,
            output_padding,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ConvTransposeAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ConvTransposeAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ConvTransposeAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ConvTransposeAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ConvTransposeAttrs");
        ds.field("strides", &self.strides());
        ds.field("auto_pad", &self.auto_pad());
        ds.field("pads", &self.pads());
        ds.field("groups", &self.groups());
        ds.field("output_padding", &self.output_padding());
        ds.finish()
    }
}
pub enum DequantizeLinearAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DequantizeLinearAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DequantizeLinearAttrs<'a> {
    type Inner = DequantizeLinearAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> DequantizeLinearAttrs<'a> {
    pub const VT_AXIS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DequantizeLinearAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args DequantizeLinearAttrsArgs,
    ) -> flatbuffers::WIPOffset<DequantizeLinearAttrs<'bldr>> {
        let mut builder = DequantizeLinearAttrsBuilder::new(_fbb);
        builder.add_axis(args.axis);
        builder.finish()
    }

    #[inline]
    pub fn axis(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(DequantizeLinearAttrs::VT_AXIS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for DequantizeLinearAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("axis", Self::VT_AXIS, false)?
            .finish();
        Ok(())
    }
}
pub struct DequantizeLinearAttrsArgs {
    pub axis: i32,
}
impl<'a> Default for DequantizeLinearAttrsArgs {
    #[inline]
    fn default() -> Self {
        DequantizeLinearAttrsArgs { axis: 0 }
    }
}

pub struct DequantizeLinearAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DequantizeLinearAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_axis(&mut self, axis: i32) {
        self.fbb_
            .push_slot::<i32>(DequantizeLinearAttrs::VT_AXIS, axis, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> DequantizeLinearAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        DequantizeLinearAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DequantizeLinearAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for DequantizeLinearAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("DequantizeLinearAttrs");
        ds.field("axis", &self.axis());
        ds.finish()
    }
}
pub enum EinsumAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EinsumAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EinsumAttrs<'a> {
    type Inner = EinsumAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> EinsumAttrs<'a> {
    pub const VT_EQUATION: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EinsumAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args EinsumAttrsArgs<'args>,
    ) -> flatbuffers::WIPOffset<EinsumAttrs<'bldr>> {
        let mut builder = EinsumAttrsBuilder::new(_fbb);
        if let Some(x) = args.equation {
            builder.add_equation(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn equation(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(EinsumAttrs::VT_EQUATION, None)
        }
    }
}

impl flatbuffers::Verifiable for EinsumAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "equation",
                Self::VT_EQUATION,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct EinsumAttrsArgs<'a> {
    pub equation: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EinsumAttrsArgs<'a> {
    #[inline]
    fn default() -> Self {
        EinsumAttrsArgs { equation: None }
    }
}

pub struct EinsumAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EinsumAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_equation(&mut self, equation: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(EinsumAttrs::VT_EQUATION, equation);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> EinsumAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        EinsumAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EinsumAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for EinsumAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("EinsumAttrs");
        ds.field("equation", &self.equation());
        ds.finish()
    }
}
pub enum EluAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EluAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EluAttrs<'a> {
    type Inner = EluAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> EluAttrs<'a> {
    pub const VT_ALPHA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EluAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args EluAttrsArgs,
    ) -> flatbuffers::WIPOffset<EluAttrs<'bldr>> {
        let mut builder = EluAttrsBuilder::new(_fbb);
        builder.add_alpha(args.alpha);
        builder.finish()
    }

    #[inline]
    pub fn alpha(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<f32>(EluAttrs::VT_ALPHA, Some(0.0)).unwrap() }
    }
}

impl flatbuffers::Verifiable for EluAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("alpha", Self::VT_ALPHA, false)?
            .finish();
        Ok(())
    }
}
pub struct EluAttrsArgs {
    pub alpha: f32,
}
impl<'a> Default for EluAttrsArgs {
    #[inline]
    fn default() -> Self {
        EluAttrsArgs { alpha: 0.0 }
    }
}

pub struct EluAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EluAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_alpha(&mut self, alpha: f32) {
        self.fbb_.push_slot::<f32>(EluAttrs::VT_ALPHA, alpha, 0.0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EluAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        EluAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EluAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for EluAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("EluAttrs");
        ds.field("alpha", &self.alpha());
        ds.finish()
    }
}
pub enum FlattenAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FlattenAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FlattenAttrs<'a> {
    type Inner = FlattenAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> FlattenAttrs<'a> {
    pub const VT_AXIS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FlattenAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args FlattenAttrsArgs,
    ) -> flatbuffers::WIPOffset<FlattenAttrs<'bldr>> {
        let mut builder = FlattenAttrsBuilder::new(_fbb);
        builder.add_axis(args.axis);
        builder.finish()
    }

    #[inline]
    pub fn axis(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(FlattenAttrs::VT_AXIS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for FlattenAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("axis", Self::VT_AXIS, false)?
            .finish();
        Ok(())
    }
}
pub struct FlattenAttrsArgs {
    pub axis: i32,
}
impl<'a> Default for FlattenAttrsArgs {
    #[inline]
    fn default() -> Self {
        FlattenAttrsArgs { axis: 0 }
    }
}

pub struct FlattenAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FlattenAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_axis(&mut self, axis: i32) {
        self.fbb_.push_slot::<i32>(FlattenAttrs::VT_AXIS, axis, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> FlattenAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        FlattenAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FlattenAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for FlattenAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("FlattenAttrs");
        ds.field("axis", &self.axis());
        ds.finish()
    }
}
pub enum LayerNormalizationAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LayerNormalizationAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LayerNormalizationAttrs<'a> {
    type Inner = LayerNormalizationAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> LayerNormalizationAttrs<'a> {
    pub const VT_AXIS: flatbuffers::VOffsetT = 4;
    pub const VT_EPSILON: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        LayerNormalizationAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args LayerNormalizationAttrsArgs,
    ) -> flatbuffers::WIPOffset<LayerNormalizationAttrs<'bldr>> {
        let mut builder = LayerNormalizationAttrsBuilder::new(_fbb);
        builder.add_epsilon(args.epsilon);
        builder.add_axis(args.axis);
        builder.finish()
    }

    #[inline]
    pub fn axis(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(LayerNormalizationAttrs::VT_AXIS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn epsilon(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(LayerNormalizationAttrs::VT_EPSILON, Some(0.0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for LayerNormalizationAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("axis", Self::VT_AXIS, false)?
            .visit_field::<f32>("epsilon", Self::VT_EPSILON, false)?
            .finish();
        Ok(())
    }
}
pub struct LayerNormalizationAttrsArgs {
    pub axis: i32,
    pub epsilon: f32,
}
impl<'a> Default for LayerNormalizationAttrsArgs {
    #[inline]
    fn default() -> Self {
        LayerNormalizationAttrsArgs {
            axis: 0,
            epsilon: 0.0,
        }
    }
}

pub struct LayerNormalizationAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LayerNormalizationAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_axis(&mut self, axis: i32) {
        self.fbb_
            .push_slot::<i32>(LayerNormalizationAttrs::VT_AXIS, axis, 0);
    }
    #[inline]
    pub fn add_epsilon(&mut self, epsilon: f32) {
        self.fbb_
            .push_slot::<f32>(LayerNormalizationAttrs::VT_EPSILON, epsilon, 0.0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> LayerNormalizationAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        LayerNormalizationAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<LayerNormalizationAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for LayerNormalizationAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("LayerNormalizationAttrs");
        ds.field("axis", &self.axis());
        ds.field("epsilon", &self.epsilon());
        ds.finish()
    }
}
pub enum GatherAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GatherAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GatherAttrs<'a> {
    type Inner = GatherAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> GatherAttrs<'a> {
    pub const VT_AXIS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GatherAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args GatherAttrsArgs,
    ) -> flatbuffers::WIPOffset<GatherAttrs<'bldr>> {
        let mut builder = GatherAttrsBuilder::new(_fbb);
        builder.add_axis(args.axis);
        builder.finish()
    }

    #[inline]
    pub fn axis(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i32>(GatherAttrs::VT_AXIS, Some(0)).unwrap() }
    }
}

impl flatbuffers::Verifiable for GatherAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("axis", Self::VT_AXIS, false)?
            .finish();
        Ok(())
    }
}
pub struct GatherAttrsArgs {
    pub axis: i32,
}
impl<'a> Default for GatherAttrsArgs {
    #[inline]
    fn default() -> Self {
        GatherAttrsArgs { axis: 0 }
    }
}

pub struct GatherAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GatherAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_axis(&mut self, axis: i32) {
        self.fbb_.push_slot::<i32>(GatherAttrs::VT_AXIS, axis, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> GatherAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        GatherAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<GatherAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for GatherAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("GatherAttrs");
        ds.field("axis", &self.axis());
        ds.finish()
    }
}
pub enum GatherNDAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GatherNDAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GatherNDAttrs<'a> {
    type Inner = GatherNDAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> GatherNDAttrs<'a> {
    pub const VT_BATCH_DIMS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GatherNDAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args GatherNDAttrsArgs,
    ) -> flatbuffers::WIPOffset<GatherNDAttrs<'bldr>> {
        let mut builder = GatherNDAttrsBuilder::new(_fbb);
        builder.add_batch_dims(args.batch_dims);
        builder.finish()
    }

    #[inline]
    pub fn batch_dims(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(GatherNDAttrs::VT_BATCH_DIMS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for GatherNDAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("batch_dims", Self::VT_BATCH_DIMS, false)?
            .finish();
        Ok(())
    }
}
pub struct GatherNDAttrsArgs {
    pub batch_dims: i32,
}
impl<'a> Default for GatherNDAttrsArgs {
    #[inline]
    fn default() -> Self {
        GatherNDAttrsArgs { batch_dims: 0 }
    }
}

pub struct GatherNDAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GatherNDAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_batch_dims(&mut self, batch_dims: i32) {
        self.fbb_
            .push_slot::<i32>(GatherNDAttrs::VT_BATCH_DIMS, batch_dims, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> GatherNDAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        GatherNDAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<GatherNDAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for GatherNDAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("GatherNDAttrs");
        ds.field("batch_dims", &self.batch_dims());
        ds.finish()
    }
}
pub enum GeluAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GeluAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GeluAttrs<'a> {
    type Inner = GeluAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> GeluAttrs<'a> {
    pub const VT_APPROXIMATE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GeluAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args GeluAttrsArgs,
    ) -> flatbuffers::WIPOffset<GeluAttrs<'bldr>> {
        let mut builder = GeluAttrsBuilder::new(_fbb);
        builder.add_approximate(args.approximate);
        builder.finish()
    }

    #[inline]
    pub fn approximate(&self) -> GeluApproximation {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<GeluApproximation>(GeluAttrs::VT_APPROXIMATE, Some(GeluApproximation::None))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for GeluAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<GeluApproximation>("approximate", Self::VT_APPROXIMATE, false)?
            .finish();
        Ok(())
    }
}
pub struct GeluAttrsArgs {
    pub approximate: GeluApproximation,
}
impl<'a> Default for GeluAttrsArgs {
    #[inline]
    fn default() -> Self {
        GeluAttrsArgs {
            approximate: GeluApproximation::None,
        }
    }
}

pub struct GeluAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GeluAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_approximate(&mut self, approximate: GeluApproximation) {
        self.fbb_.push_slot::<GeluApproximation>(
            GeluAttrs::VT_APPROXIMATE,
            approximate,
            GeluApproximation::None,
        );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GeluAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        GeluAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<GeluAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for GeluAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("GeluAttrs");
        ds.field("approximate", &self.approximate());
        ds.finish()
    }
}
pub enum GemmAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GemmAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GemmAttrs<'a> {
    type Inner = GemmAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> GemmAttrs<'a> {
    pub const VT_ALPHA: flatbuffers::VOffsetT = 4;
    pub const VT_BETA: flatbuffers::VOffsetT = 6;
    pub const VT_TRANSPOSE_A: flatbuffers::VOffsetT = 8;
    pub const VT_TRANSPOSE_B: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GemmAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args GemmAttrsArgs,
    ) -> flatbuffers::WIPOffset<GemmAttrs<'bldr>> {
        let mut builder = GemmAttrsBuilder::new(_fbb);
        builder.add_beta(args.beta);
        builder.add_alpha(args.alpha);
        builder.add_transpose_b(args.transpose_b);
        builder.add_transpose_a(args.transpose_a);
        builder.finish()
    }

    #[inline]
    pub fn alpha(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(GemmAttrs::VT_ALPHA, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn beta(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<f32>(GemmAttrs::VT_BETA, Some(0.0)).unwrap() }
    }
    #[inline]
    pub fn transpose_a(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(GemmAttrs::VT_TRANSPOSE_A, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn transpose_b(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(GemmAttrs::VT_TRANSPOSE_B, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for GemmAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("alpha", Self::VT_ALPHA, false)?
            .visit_field::<f32>("beta", Self::VT_BETA, false)?
            .visit_field::<bool>("transpose_a", Self::VT_TRANSPOSE_A, false)?
            .visit_field::<bool>("transpose_b", Self::VT_TRANSPOSE_B, false)?
            .finish();
        Ok(())
    }
}
pub struct GemmAttrsArgs {
    pub alpha: f32,
    pub beta: f32,
    pub transpose_a: bool,
    pub transpose_b: bool,
}
impl<'a> Default for GemmAttrsArgs {
    #[inline]
    fn default() -> Self {
        GemmAttrsArgs {
            alpha: 0.0,
            beta: 0.0,
            transpose_a: false,
            transpose_b: false,
        }
    }
}

pub struct GemmAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GemmAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_alpha(&mut self, alpha: f32) {
        self.fbb_.push_slot::<f32>(GemmAttrs::VT_ALPHA, alpha, 0.0);
    }
    #[inline]
    pub fn add_beta(&mut self, beta: f32) {
        self.fbb_.push_slot::<f32>(GemmAttrs::VT_BETA, beta, 0.0);
    }
    #[inline]
    pub fn add_transpose_a(&mut self, transpose_a: bool) {
        self.fbb_
            .push_slot::<bool>(GemmAttrs::VT_TRANSPOSE_A, transpose_a, false);
    }
    #[inline]
    pub fn add_transpose_b(&mut self, transpose_b: bool) {
        self.fbb_
            .push_slot::<bool>(GemmAttrs::VT_TRANSPOSE_B, transpose_b, false);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GemmAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        GemmAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<GemmAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for GemmAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("GemmAttrs");
        ds.field("alpha", &self.alpha());
        ds.field("beta", &self.beta());
        ds.field("transpose_a", &self.transpose_a());
        ds.field("transpose_b", &self.transpose_b());
        ds.finish()
    }
}
pub enum GRUAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GRUAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GRUAttrs<'a> {
    type Inner = GRUAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> GRUAttrs<'a> {
    pub const VT_DIRECTION: flatbuffers::VOffsetT = 4;
    pub const VT_HIDDEN_SIZE: flatbuffers::VOffsetT = 6;
    pub const VT_LINEAR_BEFORE_RESET: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GRUAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args GRUAttrsArgs,
    ) -> flatbuffers::WIPOffset<GRUAttrs<'bldr>> {
        let mut builder = GRUAttrsBuilder::new(_fbb);
        builder.add_hidden_size(args.hidden_size);
        builder.add_linear_before_reset(args.linear_before_reset);
        builder.add_direction(args.direction);
        builder.finish()
    }

    #[inline]
    pub fn direction(&self) -> RNNDirection {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<RNNDirection>(GRUAttrs::VT_DIRECTION, Some(RNNDirection::Forward))
                .unwrap()
        }
    }
    #[inline]
    pub fn hidden_size(&self) -> u32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u32>(GRUAttrs::VT_HIDDEN_SIZE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn linear_before_reset(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(GRUAttrs::VT_LINEAR_BEFORE_RESET, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for GRUAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<RNNDirection>("direction", Self::VT_DIRECTION, false)?
            .visit_field::<u32>("hidden_size", Self::VT_HIDDEN_SIZE, false)?
            .visit_field::<bool>("linear_before_reset", Self::VT_LINEAR_BEFORE_RESET, false)?
            .finish();
        Ok(())
    }
}
pub struct GRUAttrsArgs {
    pub direction: RNNDirection,
    pub hidden_size: u32,
    pub linear_before_reset: bool,
}
impl<'a> Default for GRUAttrsArgs {
    #[inline]
    fn default() -> Self {
        GRUAttrsArgs {
            direction: RNNDirection::Forward,
            hidden_size: 0,
            linear_before_reset: false,
        }
    }
}

pub struct GRUAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GRUAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_direction(&mut self, direction: RNNDirection) {
        self.fbb_.push_slot::<RNNDirection>(
            GRUAttrs::VT_DIRECTION,
            direction,
            RNNDirection::Forward,
        );
    }
    #[inline]
    pub fn add_hidden_size(&mut self, hidden_size: u32) {
        self.fbb_
            .push_slot::<u32>(GRUAttrs::VT_HIDDEN_SIZE, hidden_size, 0);
    }
    #[inline]
    pub fn add_linear_before_reset(&mut self, linear_before_reset: bool) {
        self.fbb_
            .push_slot::<bool>(GRUAttrs::VT_LINEAR_BEFORE_RESET, linear_before_reset, false);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GRUAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        GRUAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<GRUAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for GRUAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("GRUAttrs");
        ds.field("direction", &self.direction());
        ds.field("hidden_size", &self.hidden_size());
        ds.field("linear_before_reset", &self.linear_before_reset());
        ds.finish()
    }
}
pub enum HardSigmoidAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HardSigmoidAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HardSigmoidAttrs<'a> {
    type Inner = HardSigmoidAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> HardSigmoidAttrs<'a> {
    pub const VT_ALPHA: flatbuffers::VOffsetT = 4;
    pub const VT_BETA: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        HardSigmoidAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args HardSigmoidAttrsArgs,
    ) -> flatbuffers::WIPOffset<HardSigmoidAttrs<'bldr>> {
        let mut builder = HardSigmoidAttrsBuilder::new(_fbb);
        builder.add_beta(args.beta);
        builder.add_alpha(args.alpha);
        builder.finish()
    }

    #[inline]
    pub fn alpha(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(HardSigmoidAttrs::VT_ALPHA, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn beta(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(HardSigmoidAttrs::VT_BETA, Some(0.0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for HardSigmoidAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("alpha", Self::VT_ALPHA, false)?
            .visit_field::<f32>("beta", Self::VT_BETA, false)?
            .finish();
        Ok(())
    }
}
pub struct HardSigmoidAttrsArgs {
    pub alpha: f32,
    pub beta: f32,
}
impl<'a> Default for HardSigmoidAttrsArgs {
    #[inline]
    fn default() -> Self {
        HardSigmoidAttrsArgs {
            alpha: 0.0,
            beta: 0.0,
        }
    }
}

pub struct HardSigmoidAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> HardSigmoidAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_alpha(&mut self, alpha: f32) {
        self.fbb_
            .push_slot::<f32>(HardSigmoidAttrs::VT_ALPHA, alpha, 0.0);
    }
    #[inline]
    pub fn add_beta(&mut self, beta: f32) {
        self.fbb_
            .push_slot::<f32>(HardSigmoidAttrs::VT_BETA, beta, 0.0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> HardSigmoidAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        HardSigmoidAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<HardSigmoidAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for HardSigmoidAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("HardSigmoidAttrs");
        ds.field("alpha", &self.alpha());
        ds.field("beta", &self.beta());
        ds.finish()
    }
}
pub enum IfAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IfAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IfAttrs<'a> {
    type Inner = IfAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> IfAttrs<'a> {
    pub const VT_THEN_BRANCH: flatbuffers::VOffsetT = 4;
    pub const VT_ELSE_BRANCH: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IfAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args IfAttrsArgs<'args>,
    ) -> flatbuffers::WIPOffset<IfAttrs<'bldr>> {
        let mut builder = IfAttrsBuilder::new(_fbb);
        if let Some(x) = args.else_branch {
            builder.add_else_branch(x);
        }
        if let Some(x) = args.then_branch {
            builder.add_then_branch(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn then_branch(&self) -> Option<Graph<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Graph>>(IfAttrs::VT_THEN_BRANCH, None)
        }
    }
    #[inline]
    pub fn else_branch(&self) -> Option<Graph<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Graph>>(IfAttrs::VT_ELSE_BRANCH, None)
        }
    }
}

impl flatbuffers::Verifiable for IfAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<Graph>>(
                "then_branch",
                Self::VT_THEN_BRANCH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<Graph>>(
                "else_branch",
                Self::VT_ELSE_BRANCH,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct IfAttrsArgs<'a> {
    pub then_branch: Option<flatbuffers::WIPOffset<Graph<'a>>>,
    pub else_branch: Option<flatbuffers::WIPOffset<Graph<'a>>>,
}
impl<'a> Default for IfAttrsArgs<'a> {
    #[inline]
    fn default() -> Self {
        IfAttrsArgs {
            then_branch: None,
            else_branch: None,
        }
    }
}

pub struct IfAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IfAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_then_branch(&mut self, then_branch: flatbuffers::WIPOffset<Graph<'b>>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Graph>>(
            IfAttrs::VT_THEN_BRANCH,
            then_branch,
        );
    }
    #[inline]
    pub fn add_else_branch(&mut self, else_branch: flatbuffers::WIPOffset<Graph<'b>>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Graph>>(
            IfAttrs::VT_ELSE_BRANCH,
            else_branch,
        );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IfAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        IfAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<IfAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for IfAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("IfAttrs");
        ds.field("then_branch", &self.then_branch());
        ds.field("else_branch", &self.else_branch());
        ds.finish()
    }
}
pub enum LeakyReluAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LeakyReluAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LeakyReluAttrs<'a> {
    type Inner = LeakyReluAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> LeakyReluAttrs<'a> {
    pub const VT_ALPHA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        LeakyReluAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args LeakyReluAttrsArgs,
    ) -> flatbuffers::WIPOffset<LeakyReluAttrs<'bldr>> {
        let mut builder = LeakyReluAttrsBuilder::new(_fbb);
        builder.add_alpha(args.alpha);
        builder.finish()
    }

    #[inline]
    pub fn alpha(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(LeakyReluAttrs::VT_ALPHA, Some(0.0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for LeakyReluAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("alpha", Self::VT_ALPHA, false)?
            .finish();
        Ok(())
    }
}
pub struct LeakyReluAttrsArgs {
    pub alpha: f32,
}
impl<'a> Default for LeakyReluAttrsArgs {
    #[inline]
    fn default() -> Self {
        LeakyReluAttrsArgs { alpha: 0.0 }
    }
}

pub struct LeakyReluAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LeakyReluAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_alpha(&mut self, alpha: f32) {
        self.fbb_
            .push_slot::<f32>(LeakyReluAttrs::VT_ALPHA, alpha, 0.0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> LeakyReluAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        LeakyReluAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<LeakyReluAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for LeakyReluAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("LeakyReluAttrs");
        ds.field("alpha", &self.alpha());
        ds.finish()
    }
}
pub enum LSTMAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LSTMAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LSTMAttrs<'a> {
    type Inner = LSTMAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> LSTMAttrs<'a> {
    pub const VT_DIRECTION: flatbuffers::VOffsetT = 4;
    pub const VT_HIDDEN_SIZE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        LSTMAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args LSTMAttrsArgs,
    ) -> flatbuffers::WIPOffset<LSTMAttrs<'bldr>> {
        let mut builder = LSTMAttrsBuilder::new(_fbb);
        builder.add_hidden_size(args.hidden_size);
        builder.add_direction(args.direction);
        builder.finish()
    }

    #[inline]
    pub fn direction(&self) -> RNNDirection {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<RNNDirection>(LSTMAttrs::VT_DIRECTION, Some(RNNDirection::Forward))
                .unwrap()
        }
    }
    #[inline]
    pub fn hidden_size(&self) -> u32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u32>(LSTMAttrs::VT_HIDDEN_SIZE, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for LSTMAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<RNNDirection>("direction", Self::VT_DIRECTION, false)?
            .visit_field::<u32>("hidden_size", Self::VT_HIDDEN_SIZE, false)?
            .finish();
        Ok(())
    }
}
pub struct LSTMAttrsArgs {
    pub direction: RNNDirection,
    pub hidden_size: u32,
}
impl<'a> Default for LSTMAttrsArgs {
    #[inline]
    fn default() -> Self {
        LSTMAttrsArgs {
            direction: RNNDirection::Forward,
            hidden_size: 0,
        }
    }
}

pub struct LSTMAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LSTMAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_direction(&mut self, direction: RNNDirection) {
        self.fbb_.push_slot::<RNNDirection>(
            LSTMAttrs::VT_DIRECTION,
            direction,
            RNNDirection::Forward,
        );
    }
    #[inline]
    pub fn add_hidden_size(&mut self, hidden_size: u32) {
        self.fbb_
            .push_slot::<u32>(LSTMAttrs::VT_HIDDEN_SIZE, hidden_size, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LSTMAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        LSTMAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<LSTMAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for LSTMAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("LSTMAttrs");
        ds.field("direction", &self.direction());
        ds.field("hidden_size", &self.hidden_size());
        ds.finish()
    }
}
pub enum MaxPoolAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MaxPoolAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MaxPoolAttrs<'a> {
    type Inner = MaxPoolAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> MaxPoolAttrs<'a> {
    pub const VT_KERNEL_SIZE: flatbuffers::VOffsetT = 4;
    pub const VT_AUTO_PAD: flatbuffers::VOffsetT = 6;
    pub const VT_PADS: flatbuffers::VOffsetT = 8;
    pub const VT_STRIDES: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MaxPoolAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args MaxPoolAttrsArgs<'args>,
    ) -> flatbuffers::WIPOffset<MaxPoolAttrs<'bldr>> {
        let mut builder = MaxPoolAttrsBuilder::new(_fbb);
        if let Some(x) = args.strides {
            builder.add_strides(x);
        }
        if let Some(x) = args.pads {
            builder.add_pads(x);
        }
        if let Some(x) = args.kernel_size {
            builder.add_kernel_size(x);
        }
        builder.add_auto_pad(args.auto_pad);
        builder.finish()
    }

    #[inline]
    pub fn kernel_size(&self) -> flatbuffers::Vector<'a, u32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    MaxPoolAttrs::VT_KERNEL_SIZE,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn auto_pad(&self) -> AutoPad {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<AutoPad>(MaxPoolAttrs::VT_AUTO_PAD, Some(AutoPad::Same))
                .unwrap()
        }
    }
    #[inline]
    pub fn pads(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    MaxPoolAttrs::VT_PADS,
                    None,
                )
        }
    }
    #[inline]
    pub fn strides(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    MaxPoolAttrs::VT_STRIDES,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for MaxPoolAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "kernel_size",
                Self::VT_KERNEL_SIZE,
                true,
            )?
            .visit_field::<AutoPad>("auto_pad", Self::VT_AUTO_PAD, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "pads",
                Self::VT_PADS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "strides",
                Self::VT_STRIDES,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct MaxPoolAttrsArgs<'a> {
    pub kernel_size: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub auto_pad: AutoPad,
    pub pads: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub strides: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for MaxPoolAttrsArgs<'a> {
    #[inline]
    fn default() -> Self {
        MaxPoolAttrsArgs {
            kernel_size: None, // required field
            auto_pad: AutoPad::Same,
            pads: None,
            strides: None,
        }
    }
}

pub struct MaxPoolAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MaxPoolAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_kernel_size(
        &mut self,
        kernel_size: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MaxPoolAttrs::VT_KERNEL_SIZE,
            kernel_size,
        );
    }
    #[inline]
    pub fn add_auto_pad(&mut self, auto_pad: AutoPad) {
        self.fbb_
            .push_slot::<AutoPad>(MaxPoolAttrs::VT_AUTO_PAD, auto_pad, AutoPad::Same);
    }
    #[inline]
    pub fn add_pads(&mut self, pads: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(MaxPoolAttrs::VT_PADS, pads);
    }
    #[inline]
    pub fn add_strides(&mut self, strides: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(MaxPoolAttrs::VT_STRIDES, strides);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> MaxPoolAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        MaxPoolAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MaxPoolAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, MaxPoolAttrs::VT_KERNEL_SIZE, "kernel_size");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for MaxPoolAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("MaxPoolAttrs");
        ds.field("kernel_size", &self.kernel_size());
        ds.field("auto_pad", &self.auto_pad());
        ds.field("pads", &self.pads());
        ds.field("strides", &self.strides());
        ds.finish()
    }
}
pub enum ModAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ModAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ModAttrs<'a> {
    type Inner = ModAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ModAttrs<'a> {
    pub const VT_FMOD: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ModAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ModAttrsArgs,
    ) -> flatbuffers::WIPOffset<ModAttrs<'bldr>> {
        let mut builder = ModAttrsBuilder::new(_fbb);
        builder.add_fmod(args.fmod);
        builder.finish()
    }

    #[inline]
    pub fn fmod(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(ModAttrs::VT_FMOD, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for ModAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("fmod", Self::VT_FMOD, false)?
            .finish();
        Ok(())
    }
}
pub struct ModAttrsArgs {
    pub fmod: bool,
}
impl<'a> Default for ModAttrsArgs {
    #[inline]
    fn default() -> Self {
        ModAttrsArgs { fmod: false }
    }
}

pub struct ModAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ModAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_fmod(&mut self, fmod: bool) {
        self.fbb_.push_slot::<bool>(ModAttrs::VT_FMOD, fmod, false);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ModAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ModAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ModAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ModAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ModAttrs");
        ds.field("fmod", &self.fmod());
        ds.finish()
    }
}
pub enum NonMaxSuppressionAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NonMaxSuppressionAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NonMaxSuppressionAttrs<'a> {
    type Inner = NonMaxSuppressionAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> NonMaxSuppressionAttrs<'a> {
    pub const VT_BOX_ORDER: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        NonMaxSuppressionAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args NonMaxSuppressionAttrsArgs,
    ) -> flatbuffers::WIPOffset<NonMaxSuppressionAttrs<'bldr>> {
        let mut builder = NonMaxSuppressionAttrsBuilder::new(_fbb);
        builder.add_box_order(args.box_order);
        builder.finish()
    }

    #[inline]
    pub fn box_order(&self) -> NMSBoxOrder {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<NMSBoxOrder>(
                    NonMaxSuppressionAttrs::VT_BOX_ORDER,
                    Some(NMSBoxOrder::TopLeftBottomRight),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for NonMaxSuppressionAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<NMSBoxOrder>("box_order", Self::VT_BOX_ORDER, false)?
            .finish();
        Ok(())
    }
}
pub struct NonMaxSuppressionAttrsArgs {
    pub box_order: NMSBoxOrder,
}
impl<'a> Default for NonMaxSuppressionAttrsArgs {
    #[inline]
    fn default() -> Self {
        NonMaxSuppressionAttrsArgs {
            box_order: NMSBoxOrder::TopLeftBottomRight,
        }
    }
}

pub struct NonMaxSuppressionAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NonMaxSuppressionAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_box_order(&mut self, box_order: NMSBoxOrder) {
        self.fbb_.push_slot::<NMSBoxOrder>(
            NonMaxSuppressionAttrs::VT_BOX_ORDER,
            box_order,
            NMSBoxOrder::TopLeftBottomRight,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> NonMaxSuppressionAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        NonMaxSuppressionAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<NonMaxSuppressionAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for NonMaxSuppressionAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("NonMaxSuppressionAttrs");
        ds.field("box_order", &self.box_order());
        ds.finish()
    }
}
pub enum OneHotAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OneHotAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OneHotAttrs<'a> {
    type Inner = OneHotAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> OneHotAttrs<'a> {
    pub const VT_AXIS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        OneHotAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args OneHotAttrsArgs,
    ) -> flatbuffers::WIPOffset<OneHotAttrs<'bldr>> {
        let mut builder = OneHotAttrsBuilder::new(_fbb);
        builder.add_axis(args.axis);
        builder.finish()
    }

    #[inline]
    pub fn axis(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i32>(OneHotAttrs::VT_AXIS, Some(0)).unwrap() }
    }
}

impl flatbuffers::Verifiable for OneHotAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("axis", Self::VT_AXIS, false)?
            .finish();
        Ok(())
    }
}
pub struct OneHotAttrsArgs {
    pub axis: i32,
}
impl<'a> Default for OneHotAttrsArgs {
    #[inline]
    fn default() -> Self {
        OneHotAttrsArgs { axis: 0 }
    }
}

pub struct OneHotAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OneHotAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_axis(&mut self, axis: i32) {
        self.fbb_.push_slot::<i32>(OneHotAttrs::VT_AXIS, axis, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> OneHotAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        OneHotAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<OneHotAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for OneHotAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("OneHotAttrs");
        ds.field("axis", &self.axis());
        ds.finish()
    }
}
pub enum PadAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PadAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PadAttrs<'a> {
    type Inner = PadAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> PadAttrs<'a> {
    pub const VT_MODE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PadAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args PadAttrsArgs,
    ) -> flatbuffers::WIPOffset<PadAttrs<'bldr>> {
        let mut builder = PadAttrsBuilder::new(_fbb);
        builder.add_mode(args.mode);
        builder.finish()
    }

    #[inline]
    pub fn mode(&self) -> PadMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<PadMode>(PadAttrs::VT_MODE, Some(PadMode::Constant))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for PadAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<PadMode>("mode", Self::VT_MODE, false)?
            .finish();
        Ok(())
    }
}
pub struct PadAttrsArgs {
    pub mode: PadMode,
}
impl<'a> Default for PadAttrsArgs {
    #[inline]
    fn default() -> Self {
        PadAttrsArgs {
            mode: PadMode::Constant,
        }
    }
}

pub struct PadAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PadAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_mode(&mut self, mode: PadMode) {
        self.fbb_
            .push_slot::<PadMode>(PadAttrs::VT_MODE, mode, PadMode::Constant);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PadAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        PadAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<PadAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for PadAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("PadAttrs");
        ds.field("mode", &self.mode());
        ds.finish()
    }
}
pub enum QuantizeLinearAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct QuantizeLinearAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for QuantizeLinearAttrs<'a> {
    type Inner = QuantizeLinearAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> QuantizeLinearAttrs<'a> {
    pub const VT_AXIS: flatbuffers::VOffsetT = 4;
    pub const VT_OUTPUT_DTYPE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        QuantizeLinearAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args QuantizeLinearAttrsArgs,
    ) -> flatbuffers::WIPOffset<QuantizeLinearAttrs<'bldr>> {
        let mut builder = QuantizeLinearAttrsBuilder::new(_fbb);
        builder.add_axis(args.axis);
        if let Some(x) = args.output_dtype {
            builder.add_output_dtype(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn axis(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(QuantizeLinearAttrs::VT_AXIS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn output_dtype(&self) -> Option<DataType> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<DataType>(QuantizeLinearAttrs::VT_OUTPUT_DTYPE, None)
        }
    }
}

impl flatbuffers::Verifiable for QuantizeLinearAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("axis", Self::VT_AXIS, false)?
            .visit_field::<DataType>("output_dtype", Self::VT_OUTPUT_DTYPE, false)?
            .finish();
        Ok(())
    }
}
pub struct QuantizeLinearAttrsArgs {
    pub axis: i32,
    pub output_dtype: Option<DataType>,
}
impl<'a> Default for QuantizeLinearAttrsArgs {
    #[inline]
    fn default() -> Self {
        QuantizeLinearAttrsArgs {
            axis: 0,
            output_dtype: None,
        }
    }
}

pub struct QuantizeLinearAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> QuantizeLinearAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_axis(&mut self, axis: i32) {
        self.fbb_
            .push_slot::<i32>(QuantizeLinearAttrs::VT_AXIS, axis, 0);
    }
    #[inline]
    pub fn add_output_dtype(&mut self, output_dtype: DataType) {
        self.fbb_
            .push_slot_always::<DataType>(QuantizeLinearAttrs::VT_OUTPUT_DTYPE, output_dtype);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> QuantizeLinearAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        QuantizeLinearAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<QuantizeLinearAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for QuantizeLinearAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("QuantizeLinearAttrs");
        ds.field("axis", &self.axis());
        ds.field("output_dtype", &self.output_dtype());
        ds.finish()
    }
}
pub enum RandomNormalAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RandomNormalAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RandomNormalAttrs<'a> {
    type Inner = RandomNormalAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> RandomNormalAttrs<'a> {
    pub const VT_MEAN: flatbuffers::VOffsetT = 4;
    pub const VT_SCALE: flatbuffers::VOffsetT = 6;
    pub const VT_SEED: flatbuffers::VOffsetT = 8;
    pub const VT_SHAPE: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RandomNormalAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args RandomNormalAttrsArgs<'args>,
    ) -> flatbuffers::WIPOffset<RandomNormalAttrs<'bldr>> {
        let mut builder = RandomNormalAttrsBuilder::new(_fbb);
        if let Some(x) = args.shape {
            builder.add_shape(x);
        }
        if let Some(x) = args.seed {
            builder.add_seed(x);
        }
        builder.add_scale(args.scale);
        builder.add_mean(args.mean);
        builder.finish()
    }

    #[inline]
    pub fn mean(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(RandomNormalAttrs::VT_MEAN, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn scale(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(RandomNormalAttrs::VT_SCALE, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn seed(&self) -> Option<f32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<f32>(RandomNormalAttrs::VT_SEED, None) }
    }
    #[inline]
    pub fn shape(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    RandomNormalAttrs::VT_SHAPE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for RandomNormalAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("mean", Self::VT_MEAN, false)?
            .visit_field::<f32>("scale", Self::VT_SCALE, false)?
            .visit_field::<f32>("seed", Self::VT_SEED, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "shape",
                Self::VT_SHAPE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct RandomNormalAttrsArgs<'a> {
    pub mean: f32,
    pub scale: f32,
    pub seed: Option<f32>,
    pub shape: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for RandomNormalAttrsArgs<'a> {
    #[inline]
    fn default() -> Self {
        RandomNormalAttrsArgs {
            mean: 0.0,
            scale: 0.0,
            seed: None,
            shape: None,
        }
    }
}

pub struct RandomNormalAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RandomNormalAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_mean(&mut self, mean: f32) {
        self.fbb_
            .push_slot::<f32>(RandomNormalAttrs::VT_MEAN, mean, 0.0);
    }
    #[inline]
    pub fn add_scale(&mut self, scale: f32) {
        self.fbb_
            .push_slot::<f32>(RandomNormalAttrs::VT_SCALE, scale, 0.0);
    }
    #[inline]
    pub fn add_seed(&mut self, seed: f32) {
        self.fbb_
            .push_slot_always::<f32>(RandomNormalAttrs::VT_SEED, seed);
    }
    #[inline]
    pub fn add_shape(&mut self, shape: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(RandomNormalAttrs::VT_SHAPE, shape);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> RandomNormalAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        RandomNormalAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<RandomNormalAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for RandomNormalAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("RandomNormalAttrs");
        ds.field("mean", &self.mean());
        ds.field("scale", &self.scale());
        ds.field("seed", &self.seed());
        ds.field("shape", &self.shape());
        ds.finish()
    }
}
pub enum RandomNormalLikeAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RandomNormalLikeAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RandomNormalLikeAttrs<'a> {
    type Inner = RandomNormalLikeAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> RandomNormalLikeAttrs<'a> {
    pub const VT_MEAN: flatbuffers::VOffsetT = 4;
    pub const VT_SCALE: flatbuffers::VOffsetT = 6;
    pub const VT_SEED: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RandomNormalLikeAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args RandomNormalLikeAttrsArgs,
    ) -> flatbuffers::WIPOffset<RandomNormalLikeAttrs<'bldr>> {
        let mut builder = RandomNormalLikeAttrsBuilder::new(_fbb);
        if let Some(x) = args.seed {
            builder.add_seed(x);
        }
        builder.add_scale(args.scale);
        builder.add_mean(args.mean);
        builder.finish()
    }

    #[inline]
    pub fn mean(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(RandomNormalLikeAttrs::VT_MEAN, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn scale(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(RandomNormalLikeAttrs::VT_SCALE, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn seed(&self) -> Option<f32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<f32>(RandomNormalLikeAttrs::VT_SEED, None) }
    }
}

impl flatbuffers::Verifiable for RandomNormalLikeAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("mean", Self::VT_MEAN, false)?
            .visit_field::<f32>("scale", Self::VT_SCALE, false)?
            .visit_field::<f32>("seed", Self::VT_SEED, false)?
            .finish();
        Ok(())
    }
}
pub struct RandomNormalLikeAttrsArgs {
    pub mean: f32,
    pub scale: f32,
    pub seed: Option<f32>,
}
impl<'a> Default for RandomNormalLikeAttrsArgs {
    #[inline]
    fn default() -> Self {
        RandomNormalLikeAttrsArgs {
            mean: 0.0,
            scale: 0.0,
            seed: None,
        }
    }
}

pub struct RandomNormalLikeAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RandomNormalLikeAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_mean(&mut self, mean: f32) {
        self.fbb_
            .push_slot::<f32>(RandomNormalLikeAttrs::VT_MEAN, mean, 0.0);
    }
    #[inline]
    pub fn add_scale(&mut self, scale: f32) {
        self.fbb_
            .push_slot::<f32>(RandomNormalLikeAttrs::VT_SCALE, scale, 0.0);
    }
    #[inline]
    pub fn add_seed(&mut self, seed: f32) {
        self.fbb_
            .push_slot_always::<f32>(RandomNormalLikeAttrs::VT_SEED, seed);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> RandomNormalLikeAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        RandomNormalLikeAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<RandomNormalLikeAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for RandomNormalLikeAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("RandomNormalLikeAttrs");
        ds.field("mean", &self.mean());
        ds.field("scale", &self.scale());
        ds.field("seed", &self.seed());
        ds.finish()
    }
}
pub enum RandomUniformAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RandomUniformAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RandomUniformAttrs<'a> {
    type Inner = RandomUniformAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> RandomUniformAttrs<'a> {
    pub const VT_SHAPE: flatbuffers::VOffsetT = 4;
    pub const VT_HIGH: flatbuffers::VOffsetT = 6;
    pub const VT_LOW: flatbuffers::VOffsetT = 8;
    pub const VT_SEED: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RandomUniformAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args RandomUniformAttrsArgs<'args>,
    ) -> flatbuffers::WIPOffset<RandomUniformAttrs<'bldr>> {
        let mut builder = RandomUniformAttrsBuilder::new(_fbb);
        if let Some(x) = args.seed {
            builder.add_seed(x);
        }
        builder.add_low(args.low);
        builder.add_high(args.high);
        if let Some(x) = args.shape {
            builder.add_shape(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn shape(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    RandomUniformAttrs::VT_SHAPE,
                    None,
                )
        }
    }
    #[inline]
    pub fn high(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(RandomUniformAttrs::VT_HIGH, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn low(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(RandomUniformAttrs::VT_LOW, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn seed(&self) -> Option<f32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<f32>(RandomUniformAttrs::VT_SEED, None) }
    }
}

impl flatbuffers::Verifiable for RandomUniformAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "shape",
                Self::VT_SHAPE,
                false,
            )?
            .visit_field::<f32>("high", Self::VT_HIGH, false)?
            .visit_field::<f32>("low", Self::VT_LOW, false)?
            .visit_field::<f32>("seed", Self::VT_SEED, false)?
            .finish();
        Ok(())
    }
}
pub struct RandomUniformAttrsArgs<'a> {
    pub shape: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub high: f32,
    pub low: f32,
    pub seed: Option<f32>,
}
impl<'a> Default for RandomUniformAttrsArgs<'a> {
    #[inline]
    fn default() -> Self {
        RandomUniformAttrsArgs {
            shape: None,
            high: 0.0,
            low: 0.0,
            seed: None,
        }
    }
}

pub struct RandomUniformAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RandomUniformAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_shape(&mut self, shape: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(RandomUniformAttrs::VT_SHAPE, shape);
    }
    #[inline]
    pub fn add_high(&mut self, high: f32) {
        self.fbb_
            .push_slot::<f32>(RandomUniformAttrs::VT_HIGH, high, 0.0);
    }
    #[inline]
    pub fn add_low(&mut self, low: f32) {
        self.fbb_
            .push_slot::<f32>(RandomUniformAttrs::VT_LOW, low, 0.0);
    }
    #[inline]
    pub fn add_seed(&mut self, seed: f32) {
        self.fbb_
            .push_slot_always::<f32>(RandomUniformAttrs::VT_SEED, seed);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> RandomUniformAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        RandomUniformAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<RandomUniformAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for RandomUniformAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("RandomUniformAttrs");
        ds.field("shape", &self.shape());
        ds.field("high", &self.high());
        ds.field("low", &self.low());
        ds.field("seed", &self.seed());
        ds.finish()
    }
}
pub enum RandomUniformLikeAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RandomUniformLikeAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RandomUniformLikeAttrs<'a> {
    type Inner = RandomUniformLikeAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> RandomUniformLikeAttrs<'a> {
    pub const VT_HIGH: flatbuffers::VOffsetT = 4;
    pub const VT_LOW: flatbuffers::VOffsetT = 6;
    pub const VT_SEED: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RandomUniformLikeAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args RandomUniformLikeAttrsArgs,
    ) -> flatbuffers::WIPOffset<RandomUniformLikeAttrs<'bldr>> {
        let mut builder = RandomUniformLikeAttrsBuilder::new(_fbb);
        if let Some(x) = args.seed {
            builder.add_seed(x);
        }
        builder.add_low(args.low);
        builder.add_high(args.high);
        builder.finish()
    }

    #[inline]
    pub fn high(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(RandomUniformLikeAttrs::VT_HIGH, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn low(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(RandomUniformLikeAttrs::VT_LOW, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn seed(&self) -> Option<f32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<f32>(RandomUniformLikeAttrs::VT_SEED, None) }
    }
}

impl flatbuffers::Verifiable for RandomUniformLikeAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("high", Self::VT_HIGH, false)?
            .visit_field::<f32>("low", Self::VT_LOW, false)?
            .visit_field::<f32>("seed", Self::VT_SEED, false)?
            .finish();
        Ok(())
    }
}
pub struct RandomUniformLikeAttrsArgs {
    pub high: f32,
    pub low: f32,
    pub seed: Option<f32>,
}
impl<'a> Default for RandomUniformLikeAttrsArgs {
    #[inline]
    fn default() -> Self {
        RandomUniformLikeAttrsArgs {
            high: 0.0,
            low: 0.0,
            seed: None,
        }
    }
}

pub struct RandomUniformLikeAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RandomUniformLikeAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_high(&mut self, high: f32) {
        self.fbb_
            .push_slot::<f32>(RandomUniformLikeAttrs::VT_HIGH, high, 0.0);
    }
    #[inline]
    pub fn add_low(&mut self, low: f32) {
        self.fbb_
            .push_slot::<f32>(RandomUniformLikeAttrs::VT_LOW, low, 0.0);
    }
    #[inline]
    pub fn add_seed(&mut self, seed: f32) {
        self.fbb_
            .push_slot_always::<f32>(RandomUniformLikeAttrs::VT_SEED, seed);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> RandomUniformLikeAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        RandomUniformLikeAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<RandomUniformLikeAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for RandomUniformLikeAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("RandomUniformLikeAttrs");
        ds.field("high", &self.high());
        ds.field("low", &self.low());
        ds.field("seed", &self.seed());
        ds.finish()
    }
}
pub enum ReduceMeanAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReduceMeanAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReduceMeanAttrs<'a> {
    type Inner = ReduceMeanAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ReduceMeanAttrs<'a> {
    pub const VT_AXES: flatbuffers::VOffsetT = 4;
    pub const VT_KEEP_DIMS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReduceMeanAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ReduceMeanAttrsArgs<'args>,
    ) -> flatbuffers::WIPOffset<ReduceMeanAttrs<'bldr>> {
        let mut builder = ReduceMeanAttrsBuilder::new(_fbb);
        if let Some(x) = args.axes {
            builder.add_axes(x);
        }
        builder.add_keep_dims(args.keep_dims);
        builder.finish()
    }

    #[inline]
    pub fn axes(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    ReduceMeanAttrs::VT_AXES,
                    None,
                )
        }
    }
    #[inline]
    pub fn keep_dims(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(ReduceMeanAttrs::VT_KEEP_DIMS, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for ReduceMeanAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "axes",
                Self::VT_AXES,
                false,
            )?
            .visit_field::<bool>("keep_dims", Self::VT_KEEP_DIMS, false)?
            .finish();
        Ok(())
    }
}
pub struct ReduceMeanAttrsArgs<'a> {
    pub axes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub keep_dims: bool,
}
impl<'a> Default for ReduceMeanAttrsArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReduceMeanAttrsArgs {
            axes: None,
            keep_dims: false,
        }
    }
}

pub struct ReduceMeanAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ReduceMeanAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_axes(&mut self, axes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReduceMeanAttrs::VT_AXES, axes);
    }
    #[inline]
    pub fn add_keep_dims(&mut self, keep_dims: bool) {
        self.fbb_
            .push_slot::<bool>(ReduceMeanAttrs::VT_KEEP_DIMS, keep_dims, false);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ReduceMeanAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ReduceMeanAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ReduceMeanAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ReduceMeanAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ReduceMeanAttrs");
        ds.field("axes", &self.axes());
        ds.field("keep_dims", &self.keep_dims());
        ds.finish()
    }
}
pub enum ReshapeAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReshapeAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReshapeAttrs<'a> {
    type Inner = ReshapeAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ReshapeAttrs<'a> {
    pub const VT_ALLOW_ZERO: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReshapeAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ReshapeAttrsArgs,
    ) -> flatbuffers::WIPOffset<ReshapeAttrs<'bldr>> {
        let mut builder = ReshapeAttrsBuilder::new(_fbb);
        builder.add_allow_zero(args.allow_zero);
        builder.finish()
    }

    #[inline]
    pub fn allow_zero(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(ReshapeAttrs::VT_ALLOW_ZERO, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for ReshapeAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("allow_zero", Self::VT_ALLOW_ZERO, false)?
            .finish();
        Ok(())
    }
}
pub struct ReshapeAttrsArgs {
    pub allow_zero: bool,
}
impl<'a> Default for ReshapeAttrsArgs {
    #[inline]
    fn default() -> Self {
        ReshapeAttrsArgs { allow_zero: false }
    }
}

pub struct ReshapeAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ReshapeAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_allow_zero(&mut self, allow_zero: bool) {
        self.fbb_
            .push_slot::<bool>(ReshapeAttrs::VT_ALLOW_ZERO, allow_zero, false);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ReshapeAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ReshapeAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ReshapeAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ReshapeAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ReshapeAttrs");
        ds.field("allow_zero", &self.allow_zero());
        ds.finish()
    }
}
pub enum ResizeAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ResizeAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ResizeAttrs<'a> {
    type Inner = ResizeAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ResizeAttrs<'a> {
    pub const VT_MODE: flatbuffers::VOffsetT = 4;
    pub const VT_COORD_MODE: flatbuffers::VOffsetT = 6;
    pub const VT_NEAREST_MODE: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ResizeAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ResizeAttrsArgs,
    ) -> flatbuffers::WIPOffset<ResizeAttrs<'bldr>> {
        let mut builder = ResizeAttrsBuilder::new(_fbb);
        builder.add_nearest_mode(args.nearest_mode);
        builder.add_coord_mode(args.coord_mode);
        builder.add_mode(args.mode);
        builder.finish()
    }

    #[inline]
    pub fn mode(&self) -> ResizeMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<ResizeMode>(ResizeAttrs::VT_MODE, Some(ResizeMode::Nearest))
                .unwrap()
        }
    }
    #[inline]
    pub fn coord_mode(&self) -> CoordTransformMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<CoordTransformMode>(
                    ResizeAttrs::VT_COORD_MODE,
                    Some(CoordTransformMode::HalfPixel),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn nearest_mode(&self) -> NearestMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<NearestMode>(ResizeAttrs::VT_NEAREST_MODE, Some(NearestMode::Floor))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for ResizeAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<ResizeMode>("mode", Self::VT_MODE, false)?
            .visit_field::<CoordTransformMode>("coord_mode", Self::VT_COORD_MODE, false)?
            .visit_field::<NearestMode>("nearest_mode", Self::VT_NEAREST_MODE, false)?
            .finish();
        Ok(())
    }
}
pub struct ResizeAttrsArgs {
    pub mode: ResizeMode,
    pub coord_mode: CoordTransformMode,
    pub nearest_mode: NearestMode,
}
impl<'a> Default for ResizeAttrsArgs {
    #[inline]
    fn default() -> Self {
        ResizeAttrsArgs {
            mode: ResizeMode::Nearest,
            coord_mode: CoordTransformMode::HalfPixel,
            nearest_mode: NearestMode::Floor,
        }
    }
}

pub struct ResizeAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ResizeAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_mode(&mut self, mode: ResizeMode) {
        self.fbb_
            .push_slot::<ResizeMode>(ResizeAttrs::VT_MODE, mode, ResizeMode::Nearest);
    }
    #[inline]
    pub fn add_coord_mode(&mut self, coord_mode: CoordTransformMode) {
        self.fbb_.push_slot::<CoordTransformMode>(
            ResizeAttrs::VT_COORD_MODE,
            coord_mode,
            CoordTransformMode::HalfPixel,
        );
    }
    #[inline]
    pub fn add_nearest_mode(&mut self, nearest_mode: NearestMode) {
        self.fbb_.push_slot::<NearestMode>(
            ResizeAttrs::VT_NEAREST_MODE,
            nearest_mode,
            NearestMode::Floor,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ResizeAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ResizeAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ResizeAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ResizeAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ResizeAttrs");
        ds.field("mode", &self.mode());
        ds.field("coord_mode", &self.coord_mode());
        ds.field("nearest_mode", &self.nearest_mode());
        ds.finish()
    }
}
pub enum ScatterElementsAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ScatterElementsAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ScatterElementsAttrs<'a> {
    type Inner = ScatterElementsAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ScatterElementsAttrs<'a> {
    pub const VT_AXIS: flatbuffers::VOffsetT = 4;
    pub const VT_REDUCTION: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ScatterElementsAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ScatterElementsAttrsArgs,
    ) -> flatbuffers::WIPOffset<ScatterElementsAttrs<'bldr>> {
        let mut builder = ScatterElementsAttrsBuilder::new(_fbb);
        builder.add_axis(args.axis);
        builder.add_reduction(args.reduction);
        builder.finish()
    }

    #[inline]
    pub fn axis(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(ScatterElementsAttrs::VT_AXIS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn reduction(&self) -> ScatterReduction {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<ScatterReduction>(
                    ScatterElementsAttrs::VT_REDUCTION,
                    Some(ScatterReduction::None),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for ScatterElementsAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("axis", Self::VT_AXIS, false)?
            .visit_field::<ScatterReduction>("reduction", Self::VT_REDUCTION, false)?
            .finish();
        Ok(())
    }
}
pub struct ScatterElementsAttrsArgs {
    pub axis: i32,
    pub reduction: ScatterReduction,
}
impl<'a> Default for ScatterElementsAttrsArgs {
    #[inline]
    fn default() -> Self {
        ScatterElementsAttrsArgs {
            axis: 0,
            reduction: ScatterReduction::None,
        }
    }
}

pub struct ScatterElementsAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ScatterElementsAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_axis(&mut self, axis: i32) {
        self.fbb_
            .push_slot::<i32>(ScatterElementsAttrs::VT_AXIS, axis, 0);
    }
    #[inline]
    pub fn add_reduction(&mut self, reduction: ScatterReduction) {
        self.fbb_.push_slot::<ScatterReduction>(
            ScatterElementsAttrs::VT_REDUCTION,
            reduction,
            ScatterReduction::None,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ScatterElementsAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ScatterElementsAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ScatterElementsAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ScatterElementsAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ScatterElementsAttrs");
        ds.field("axis", &self.axis());
        ds.field("reduction", &self.reduction());
        ds.finish()
    }
}
pub enum ScatterNDAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ScatterNDAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ScatterNDAttrs<'a> {
    type Inner = ScatterNDAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ScatterNDAttrs<'a> {
    pub const VT_REDUCTION: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ScatterNDAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ScatterNDAttrsArgs,
    ) -> flatbuffers::WIPOffset<ScatterNDAttrs<'bldr>> {
        let mut builder = ScatterNDAttrsBuilder::new(_fbb);
        builder.add_reduction(args.reduction);
        builder.finish()
    }

    #[inline]
    pub fn reduction(&self) -> ScatterReduction {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<ScatterReduction>(ScatterNDAttrs::VT_REDUCTION, Some(ScatterReduction::None))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for ScatterNDAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<ScatterReduction>("reduction", Self::VT_REDUCTION, false)?
            .finish();
        Ok(())
    }
}
pub struct ScatterNDAttrsArgs {
    pub reduction: ScatterReduction,
}
impl<'a> Default for ScatterNDAttrsArgs {
    #[inline]
    fn default() -> Self {
        ScatterNDAttrsArgs {
            reduction: ScatterReduction::None,
        }
    }
}

pub struct ScatterNDAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ScatterNDAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_reduction(&mut self, reduction: ScatterReduction) {
        self.fbb_.push_slot::<ScatterReduction>(
            ScatterNDAttrs::VT_REDUCTION,
            reduction,
            ScatterReduction::None,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ScatterNDAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ScatterNDAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ScatterNDAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ScatterNDAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ScatterNDAttrs");
        ds.field("reduction", &self.reduction());
        ds.finish()
    }
}
pub enum ShapeAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ShapeAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ShapeAttrs<'a> {
    type Inner = ShapeAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ShapeAttrs<'a> {
    pub const VT_START: flatbuffers::VOffsetT = 4;
    pub const VT_END: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ShapeAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ShapeAttrsArgs,
    ) -> flatbuffers::WIPOffset<ShapeAttrs<'bldr>> {
        let mut builder = ShapeAttrsBuilder::new(_fbb);
        if let Some(x) = args.end {
            builder.add_end(x);
        }
        if let Some(x) = args.start {
            builder.add_start(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn start(&self) -> Option<i32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i32>(ShapeAttrs::VT_START, None) }
    }
    #[inline]
    pub fn end(&self) -> Option<i32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i32>(ShapeAttrs::VT_END, None) }
    }
}

impl flatbuffers::Verifiable for ShapeAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("start", Self::VT_START, false)?
            .visit_field::<i32>("end", Self::VT_END, false)?
            .finish();
        Ok(())
    }
}
pub struct ShapeAttrsArgs {
    pub start: Option<i32>,
    pub end: Option<i32>,
}
impl<'a> Default for ShapeAttrsArgs {
    #[inline]
    fn default() -> Self {
        ShapeAttrsArgs {
            start: None,
            end: None,
        }
    }
}

pub struct ShapeAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ShapeAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_start(&mut self, start: i32) {
        self.fbb_
            .push_slot_always::<i32>(ShapeAttrs::VT_START, start);
    }
    #[inline]
    pub fn add_end(&mut self, end: i32) {
        self.fbb_.push_slot_always::<i32>(ShapeAttrs::VT_END, end);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ShapeAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ShapeAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ShapeAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ShapeAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ShapeAttrs");
        ds.field("start", &self.start());
        ds.field("end", &self.end());
        ds.finish()
    }
}
pub enum SoftmaxAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SoftmaxAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SoftmaxAttrs<'a> {
    type Inner = SoftmaxAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> SoftmaxAttrs<'a> {
    pub const VT_AXIS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SoftmaxAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args SoftmaxAttrsArgs,
    ) -> flatbuffers::WIPOffset<SoftmaxAttrs<'bldr>> {
        let mut builder = SoftmaxAttrsBuilder::new(_fbb);
        builder.add_axis(args.axis);
        builder.finish()
    }

    #[inline]
    pub fn axis(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(SoftmaxAttrs::VT_AXIS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for SoftmaxAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("axis", Self::VT_AXIS, false)?
            .finish();
        Ok(())
    }
}
pub struct SoftmaxAttrsArgs {
    pub axis: i32,
}
impl<'a> Default for SoftmaxAttrsArgs {
    #[inline]
    fn default() -> Self {
        SoftmaxAttrsArgs { axis: 0 }
    }
}

pub struct SoftmaxAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SoftmaxAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_axis(&mut self, axis: i32) {
        self.fbb_.push_slot::<i32>(SoftmaxAttrs::VT_AXIS, axis, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> SoftmaxAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        SoftmaxAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SoftmaxAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SoftmaxAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SoftmaxAttrs");
        ds.field("axis", &self.axis());
        ds.finish()
    }
}
pub enum SplitAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SplitAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SplitAttrs<'a> {
    type Inner = SplitAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> SplitAttrs<'a> {
    pub const VT_AXIS: flatbuffers::VOffsetT = 4;
    pub const VT_NUM_OUTPUTS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SplitAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args SplitAttrsArgs,
    ) -> flatbuffers::WIPOffset<SplitAttrs<'bldr>> {
        let mut builder = SplitAttrsBuilder::new(_fbb);
        if let Some(x) = args.num_outputs {
            builder.add_num_outputs(x);
        }
        builder.add_axis(args.axis);
        builder.finish()
    }

    #[inline]
    pub fn axis(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i32>(SplitAttrs::VT_AXIS, Some(0)).unwrap() }
    }
    #[inline]
    pub fn num_outputs(&self) -> Option<i32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i32>(SplitAttrs::VT_NUM_OUTPUTS, None) }
    }
}

impl flatbuffers::Verifiable for SplitAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("axis", Self::VT_AXIS, false)?
            .visit_field::<i32>("num_outputs", Self::VT_NUM_OUTPUTS, false)?
            .finish();
        Ok(())
    }
}
pub struct SplitAttrsArgs {
    pub axis: i32,
    pub num_outputs: Option<i32>,
}
impl<'a> Default for SplitAttrsArgs {
    #[inline]
    fn default() -> Self {
        SplitAttrsArgs {
            axis: 0,
            num_outputs: None,
        }
    }
}

pub struct SplitAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SplitAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_axis(&mut self, axis: i32) {
        self.fbb_.push_slot::<i32>(SplitAttrs::VT_AXIS, axis, 0);
    }
    #[inline]
    pub fn add_num_outputs(&mut self, num_outputs: i32) {
        self.fbb_
            .push_slot_always::<i32>(SplitAttrs::VT_NUM_OUTPUTS, num_outputs);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> SplitAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        SplitAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SplitAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SplitAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SplitAttrs");
        ds.field("axis", &self.axis());
        ds.field("num_outputs", &self.num_outputs());
        ds.finish()
    }
}
pub enum TopKAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TopKAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TopKAttrs<'a> {
    type Inner = TopKAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> TopKAttrs<'a> {
    pub const VT_AXIS: flatbuffers::VOffsetT = 4;
    pub const VT_LARGEST: flatbuffers::VOffsetT = 6;
    pub const VT_SORTED: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TopKAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args TopKAttrsArgs,
    ) -> flatbuffers::WIPOffset<TopKAttrs<'bldr>> {
        let mut builder = TopKAttrsBuilder::new(_fbb);
        builder.add_axis(args.axis);
        builder.add_sorted(args.sorted);
        builder.add_largest(args.largest);
        builder.finish()
    }

    #[inline]
    pub fn axis(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i32>(TopKAttrs::VT_AXIS, Some(0)).unwrap() }
    }
    #[inline]
    pub fn largest(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(TopKAttrs::VT_LARGEST, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn sorted(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(TopKAttrs::VT_SORTED, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for TopKAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("axis", Self::VT_AXIS, false)?
            .visit_field::<bool>("largest", Self::VT_LARGEST, false)?
            .visit_field::<bool>("sorted", Self::VT_SORTED, false)?
            .finish();
        Ok(())
    }
}
pub struct TopKAttrsArgs {
    pub axis: i32,
    pub largest: bool,
    pub sorted: bool,
}
impl<'a> Default for TopKAttrsArgs {
    #[inline]
    fn default() -> Self {
        TopKAttrsArgs {
            axis: 0,
            largest: false,
            sorted: false,
        }
    }
}

pub struct TopKAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TopKAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_axis(&mut self, axis: i32) {
        self.fbb_.push_slot::<i32>(TopKAttrs::VT_AXIS, axis, 0);
    }
    #[inline]
    pub fn add_largest(&mut self, largest: bool) {
        self.fbb_
            .push_slot::<bool>(TopKAttrs::VT_LARGEST, largest, false);
    }
    #[inline]
    pub fn add_sorted(&mut self, sorted: bool) {
        self.fbb_
            .push_slot::<bool>(TopKAttrs::VT_SORTED, sorted, false);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TopKAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        TopKAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TopKAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for TopKAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("TopKAttrs");
        ds.field("axis", &self.axis());
        ds.field("largest", &self.largest());
        ds.field("sorted", &self.sorted());
        ds.finish()
    }
}
pub enum TransposeAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TransposeAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransposeAttrs<'a> {
    type Inner = TransposeAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> TransposeAttrs<'a> {
    pub const VT_PERM: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TransposeAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args TransposeAttrsArgs<'args>,
    ) -> flatbuffers::WIPOffset<TransposeAttrs<'bldr>> {
        let mut builder = TransposeAttrsBuilder::new(_fbb);
        if let Some(x) = args.perm {
            builder.add_perm(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn perm(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    TransposeAttrs::VT_PERM,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for TransposeAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "perm",
                Self::VT_PERM,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct TransposeAttrsArgs<'a> {
    pub perm: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for TransposeAttrsArgs<'a> {
    #[inline]
    fn default() -> Self {
        TransposeAttrsArgs { perm: None }
    }
}

pub struct TransposeAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransposeAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_perm(&mut self, perm: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TransposeAttrs::VT_PERM, perm);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> TransposeAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        TransposeAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TransposeAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for TransposeAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("TransposeAttrs");
        ds.field("perm", &self.perm());
        ds.finish()
    }
}
pub enum TriluAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TriluAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TriluAttrs<'a> {
    type Inner = TriluAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> TriluAttrs<'a> {
    pub const VT_UPPER: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TriluAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args TriluAttrsArgs,
    ) -> flatbuffers::WIPOffset<TriluAttrs<'bldr>> {
        let mut builder = TriluAttrsBuilder::new(_fbb);
        builder.add_upper(args.upper);
        builder.finish()
    }

    #[inline]
    pub fn upper(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(TriluAttrs::VT_UPPER, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for TriluAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("upper", Self::VT_UPPER, false)?
            .finish();
        Ok(())
    }
}
pub struct TriluAttrsArgs {
    pub upper: bool,
}
impl<'a> Default for TriluAttrsArgs {
    #[inline]
    fn default() -> Self {
        TriluAttrsArgs { upper: false }
    }
}

pub struct TriluAttrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TriluAttrsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_upper(&mut self, upper: bool) {
        self.fbb_
            .push_slot::<bool>(TriluAttrs::VT_UPPER, upper, false);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> TriluAttrsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        TriluAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TriluAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for TriluAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("TriluAttrs");
        ds.field("upper", &self.upper());
        ds.finish()
    }
}
pub enum OperatorNodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OperatorNode<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OperatorNode<'a> {
    type Inner = OperatorNode<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> OperatorNode<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_ATTRS_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_ATTRS: flatbuffers::VOffsetT = 8;
    pub const VT_INPUTS: flatbuffers::VOffsetT = 10;
    pub const VT_OUTPUTS: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        OperatorNode { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args OperatorNodeArgs<'args>,
    ) -> flatbuffers::WIPOffset<OperatorNode<'bldr>> {
        let mut builder = OperatorNodeBuilder::new(_fbb);
        if let Some(x) = args.outputs {
            builder.add_outputs(x);
        }
        if let Some(x) = args.inputs {
            builder.add_inputs(x);
        }
        if let Some(x) = args.attrs {
            builder.add_attrs(x);
        }
        builder.add_attrs_type(args.attrs_type);
        builder.add_type_(args.type_);
        builder.finish()
    }

    #[inline]
    pub fn type_(&self) -> OperatorType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<OperatorType>(OperatorNode::VT_TYPE_, Some(OperatorType::Add))
                .unwrap()
        }
    }
    #[inline]
    pub fn attrs_type(&self) -> OperatorAttrs {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<OperatorAttrs>(OperatorNode::VT_ATTRS_TYPE, Some(OperatorAttrs::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn attrs(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    OperatorNode::VT_ATTRS,
                    None,
                )
        }
    }
    #[inline]
    pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    OperatorNode::VT_INPUTS,
                    None,
                )
        }
    }
    #[inline]
    pub fn outputs(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    OperatorNode::VT_OUTPUTS,
                    None,
                )
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_arg_max_attrs(&self) -> Option<ArgMaxAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ArgMaxAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ArgMaxAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_average_pool_attrs(&self) -> Option<AveragePoolAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::AveragePoolAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { AveragePoolAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_batch_normalization_attrs(&self) -> Option<BatchNormalizationAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::BatchNormalizationAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { BatchNormalizationAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_cast_attrs(&self) -> Option<CastAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::CastAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { CastAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_concat_attrs(&self) -> Option<ConcatAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ConcatAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ConcatAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_constant_of_shape_attrs(&self) -> Option<ConstantOfShapeAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ConstantOfShapeAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ConstantOfShapeAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_conv_attrs(&self) -> Option<ConvAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ConvAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ConvAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_conv_transpose_attrs(&self) -> Option<ConvTransposeAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ConvTransposeAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ConvTransposeAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_flatten_attrs(&self) -> Option<FlattenAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::FlattenAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { FlattenAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_gather_attrs(&self) -> Option<GatherAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::GatherAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { GatherAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_gemm_attrs(&self) -> Option<GemmAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::GemmAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { GemmAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_gruattrs(&self) -> Option<GRUAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::GRUAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { GRUAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_leaky_relu_attrs(&self) -> Option<LeakyReluAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::LeakyReluAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { LeakyReluAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_lstmattrs(&self) -> Option<LSTMAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::LSTMAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { LSTMAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_max_pool_attrs(&self) -> Option<MaxPoolAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::MaxPoolAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { MaxPoolAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_reduce_mean_attrs(&self) -> Option<ReduceMeanAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ReduceMeanAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ReduceMeanAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_reshape_attrs(&self) -> Option<ReshapeAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ReshapeAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ReshapeAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_resize_attrs(&self) -> Option<ResizeAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ResizeAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ResizeAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_split_attrs(&self) -> Option<SplitAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::SplitAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { SplitAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_softmax_attrs(&self) -> Option<SoftmaxAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::SoftmaxAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { SoftmaxAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_transpose_attrs(&self) -> Option<TransposeAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::TransposeAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { TransposeAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_mod_attrs(&self) -> Option<ModAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ModAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ModAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_scatter_elements_attrs(&self) -> Option<ScatterElementsAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ScatterElementsAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ScatterElementsAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_one_hot_attrs(&self) -> Option<OneHotAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::OneHotAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { OneHotAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_top_kattrs(&self) -> Option<TopKAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::TopKAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { TopKAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_hard_sigmoid_attrs(&self) -> Option<HardSigmoidAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::HardSigmoidAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { HardSigmoidAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_trilu_attrs(&self) -> Option<TriluAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::TriluAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { TriluAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_scatter_ndattrs(&self) -> Option<ScatterNDAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ScatterNDAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ScatterNDAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_non_max_suppression_attrs(&self) -> Option<NonMaxSuppressionAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::NonMaxSuppressionAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { NonMaxSuppressionAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_layer_normalization_attrs(&self) -> Option<LayerNormalizationAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::LayerNormalizationAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { LayerNormalizationAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_random_uniform_attrs(&self) -> Option<RandomUniformAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::RandomUniformAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { RandomUniformAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_elu_attrs(&self) -> Option<EluAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::EluAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { EluAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_random_uniform_like_attrs(&self) -> Option<RandomUniformLikeAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::RandomUniformLikeAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { RandomUniformLikeAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_random_normal_attrs(&self) -> Option<RandomNormalAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::RandomNormalAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { RandomNormalAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_random_normal_like_attrs(&self) -> Option<RandomNormalLikeAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::RandomNormalLikeAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { RandomNormalLikeAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_gather_ndattrs(&self) -> Option<GatherNDAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::GatherNDAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { GatherNDAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_gelu_attrs(&self) -> Option<GeluAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::GeluAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { GeluAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_einsum_attrs(&self) -> Option<EinsumAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::EinsumAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { EinsumAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_if_attrs(&self) -> Option<IfAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::IfAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { IfAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_pad_attrs(&self) -> Option<PadAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::PadAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { PadAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_dequantize_linear_attrs(&self) -> Option<DequantizeLinearAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::DequantizeLinearAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { DequantizeLinearAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_quantize_linear_attrs(&self) -> Option<QuantizeLinearAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::QuantizeLinearAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { QuantizeLinearAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_depth_to_space_attrs(&self) -> Option<DepthToSpaceAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::DepthToSpaceAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { DepthToSpaceAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_cast_like_attrs(&self) -> Option<CastLikeAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::CastLikeAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { CastLikeAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_shape_attrs(&self) -> Option<ShapeAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ShapeAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ShapeAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_dropout_attrs(&self) -> Option<DropoutAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::DropoutAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { DropoutAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_eye_like_attrs(&self) -> Option<EyeLikeAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::EyeLikeAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { EyeLikeAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_is_inf_attrs(&self) -> Option<IsInfAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::IsInfAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { IsInfAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for OperatorNode<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<OperatorType>("type_", Self::VT_TYPE_, false)?
     .visit_union::<OperatorAttrs, _>("attrs_type", Self::VT_ATTRS_TYPE, "attrs", Self::VT_ATTRS, false, |key, v, pos| {
        match key {
          OperatorAttrs::ArgMaxAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArgMaxAttrs>>("OperatorAttrs::ArgMaxAttrs", pos),
          OperatorAttrs::AveragePoolAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AveragePoolAttrs>>("OperatorAttrs::AveragePoolAttrs", pos),
          OperatorAttrs::BatchNormalizationAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BatchNormalizationAttrs>>("OperatorAttrs::BatchNormalizationAttrs", pos),
          OperatorAttrs::CastAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CastAttrs>>("OperatorAttrs::CastAttrs", pos),
          OperatorAttrs::ConcatAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConcatAttrs>>("OperatorAttrs::ConcatAttrs", pos),
          OperatorAttrs::ConstantOfShapeAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConstantOfShapeAttrs>>("OperatorAttrs::ConstantOfShapeAttrs", pos),
          OperatorAttrs::ConvAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConvAttrs>>("OperatorAttrs::ConvAttrs", pos),
          OperatorAttrs::ConvTransposeAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConvTransposeAttrs>>("OperatorAttrs::ConvTransposeAttrs", pos),
          OperatorAttrs::FlattenAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FlattenAttrs>>("OperatorAttrs::FlattenAttrs", pos),
          OperatorAttrs::GatherAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GatherAttrs>>("OperatorAttrs::GatherAttrs", pos),
          OperatorAttrs::GemmAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GemmAttrs>>("OperatorAttrs::GemmAttrs", pos),
          OperatorAttrs::GRUAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GRUAttrs>>("OperatorAttrs::GRUAttrs", pos),
          OperatorAttrs::LeakyReluAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LeakyReluAttrs>>("OperatorAttrs::LeakyReluAttrs", pos),
          OperatorAttrs::LSTMAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LSTMAttrs>>("OperatorAttrs::LSTMAttrs", pos),
          OperatorAttrs::MaxPoolAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MaxPoolAttrs>>("OperatorAttrs::MaxPoolAttrs", pos),
          OperatorAttrs::ReduceMeanAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReduceMeanAttrs>>("OperatorAttrs::ReduceMeanAttrs", pos),
          OperatorAttrs::ReshapeAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReshapeAttrs>>("OperatorAttrs::ReshapeAttrs", pos),
          OperatorAttrs::ResizeAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ResizeAttrs>>("OperatorAttrs::ResizeAttrs", pos),
          OperatorAttrs::SplitAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SplitAttrs>>("OperatorAttrs::SplitAttrs", pos),
          OperatorAttrs::SoftmaxAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SoftmaxAttrs>>("OperatorAttrs::SoftmaxAttrs", pos),
          OperatorAttrs::TransposeAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TransposeAttrs>>("OperatorAttrs::TransposeAttrs", pos),
          OperatorAttrs::ModAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ModAttrs>>("OperatorAttrs::ModAttrs", pos),
          OperatorAttrs::ScatterElementsAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ScatterElementsAttrs>>("OperatorAttrs::ScatterElementsAttrs", pos),
          OperatorAttrs::OneHotAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<OneHotAttrs>>("OperatorAttrs::OneHotAttrs", pos),
          OperatorAttrs::TopKAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TopKAttrs>>("OperatorAttrs::TopKAttrs", pos),
          OperatorAttrs::HardSigmoidAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<HardSigmoidAttrs>>("OperatorAttrs::HardSigmoidAttrs", pos),
          OperatorAttrs::TriluAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TriluAttrs>>("OperatorAttrs::TriluAttrs", pos),
          OperatorAttrs::ScatterNDAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ScatterNDAttrs>>("OperatorAttrs::ScatterNDAttrs", pos),
          OperatorAttrs::NonMaxSuppressionAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NonMaxSuppressionAttrs>>("OperatorAttrs::NonMaxSuppressionAttrs", pos),
          OperatorAttrs::LayerNormalizationAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LayerNormalizationAttrs>>("OperatorAttrs::LayerNormalizationAttrs", pos),
          OperatorAttrs::RandomUniformAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RandomUniformAttrs>>("OperatorAttrs::RandomUniformAttrs", pos),
          OperatorAttrs::EluAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EluAttrs>>("OperatorAttrs::EluAttrs", pos),
          OperatorAttrs::RandomUniformLikeAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RandomUniformLikeAttrs>>("OperatorAttrs::RandomUniformLikeAttrs", pos),
          OperatorAttrs::RandomNormalAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RandomNormalAttrs>>("OperatorAttrs::RandomNormalAttrs", pos),
          OperatorAttrs::RandomNormalLikeAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RandomNormalLikeAttrs>>("OperatorAttrs::RandomNormalLikeAttrs", pos),
          OperatorAttrs::GatherNDAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GatherNDAttrs>>("OperatorAttrs::GatherNDAttrs", pos),
          OperatorAttrs::GeluAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GeluAttrs>>("OperatorAttrs::GeluAttrs", pos),
          OperatorAttrs::EinsumAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EinsumAttrs>>("OperatorAttrs::EinsumAttrs", pos),
          OperatorAttrs::IfAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IfAttrs>>("OperatorAttrs::IfAttrs", pos),
          OperatorAttrs::PadAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PadAttrs>>("OperatorAttrs::PadAttrs", pos),
          OperatorAttrs::DequantizeLinearAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DequantizeLinearAttrs>>("OperatorAttrs::DequantizeLinearAttrs", pos),
          OperatorAttrs::QuantizeLinearAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<QuantizeLinearAttrs>>("OperatorAttrs::QuantizeLinearAttrs", pos),
          OperatorAttrs::DepthToSpaceAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DepthToSpaceAttrs>>("OperatorAttrs::DepthToSpaceAttrs", pos),
          OperatorAttrs::CastLikeAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CastLikeAttrs>>("OperatorAttrs::CastLikeAttrs", pos),
          OperatorAttrs::ShapeAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ShapeAttrs>>("OperatorAttrs::ShapeAttrs", pos),
          OperatorAttrs::DropoutAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DropoutAttrs>>("OperatorAttrs::DropoutAttrs", pos),
          OperatorAttrs::EyeLikeAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EyeLikeAttrs>>("OperatorAttrs::EyeLikeAttrs", pos),
          OperatorAttrs::IsInfAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IsInfAttrs>>("OperatorAttrs::IsInfAttrs", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("inputs", Self::VT_INPUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("outputs", Self::VT_OUTPUTS, false)?
     .finish();
        Ok(())
    }
}
pub struct OperatorNodeArgs<'a> {
    pub type_: OperatorType,
    pub attrs_type: OperatorAttrs,
    pub attrs: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub outputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for OperatorNodeArgs<'a> {
    #[inline]
    fn default() -> Self {
        OperatorNodeArgs {
            type_: OperatorType::Add,
            attrs_type: OperatorAttrs::NONE,
            attrs: None,
            inputs: None,
            outputs: None,
        }
    }
}

pub struct OperatorNodeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OperatorNodeBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_type_(&mut self, type_: OperatorType) {
        self.fbb_
            .push_slot::<OperatorType>(OperatorNode::VT_TYPE_, type_, OperatorType::Add);
    }
    #[inline]
    pub fn add_attrs_type(&mut self, attrs_type: OperatorAttrs) {
        self.fbb_.push_slot::<OperatorAttrs>(
            OperatorNode::VT_ATTRS_TYPE,
            attrs_type,
            OperatorAttrs::NONE,
        );
    }
    #[inline]
    pub fn add_attrs(&mut self, attrs: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(OperatorNode::VT_ATTRS, attrs);
    }
    #[inline]
    pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(OperatorNode::VT_INPUTS, inputs);
    }
    #[inline]
    pub fn add_outputs(&mut self, outputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(OperatorNode::VT_OUTPUTS, outputs);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> OperatorNodeBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        OperatorNodeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<OperatorNode<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for OperatorNode<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("OperatorNode");
        ds.field("type_", &self.type_());
        ds.field("attrs_type", &self.attrs_type());
        match self.attrs_type() {
            OperatorAttrs::ArgMaxAttrs => {
                if let Some(x) = self.attrs_as_arg_max_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::AveragePoolAttrs => {
                if let Some(x) = self.attrs_as_average_pool_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::BatchNormalizationAttrs => {
                if let Some(x) = self.attrs_as_batch_normalization_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::CastAttrs => {
                if let Some(x) = self.attrs_as_cast_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ConcatAttrs => {
                if let Some(x) = self.attrs_as_concat_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ConstantOfShapeAttrs => {
                if let Some(x) = self.attrs_as_constant_of_shape_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ConvAttrs => {
                if let Some(x) = self.attrs_as_conv_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ConvTransposeAttrs => {
                if let Some(x) = self.attrs_as_conv_transpose_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::FlattenAttrs => {
                if let Some(x) = self.attrs_as_flatten_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::GatherAttrs => {
                if let Some(x) = self.attrs_as_gather_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::GemmAttrs => {
                if let Some(x) = self.attrs_as_gemm_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::GRUAttrs => {
                if let Some(x) = self.attrs_as_gruattrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::LeakyReluAttrs => {
                if let Some(x) = self.attrs_as_leaky_relu_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::LSTMAttrs => {
                if let Some(x) = self.attrs_as_lstmattrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::MaxPoolAttrs => {
                if let Some(x) = self.attrs_as_max_pool_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ReduceMeanAttrs => {
                if let Some(x) = self.attrs_as_reduce_mean_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ReshapeAttrs => {
                if let Some(x) = self.attrs_as_reshape_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ResizeAttrs => {
                if let Some(x) = self.attrs_as_resize_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::SplitAttrs => {
                if let Some(x) = self.attrs_as_split_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::SoftmaxAttrs => {
                if let Some(x) = self.attrs_as_softmax_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::TransposeAttrs => {
                if let Some(x) = self.attrs_as_transpose_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ModAttrs => {
                if let Some(x) = self.attrs_as_mod_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ScatterElementsAttrs => {
                if let Some(x) = self.attrs_as_scatter_elements_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::OneHotAttrs => {
                if let Some(x) = self.attrs_as_one_hot_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::TopKAttrs => {
                if let Some(x) = self.attrs_as_top_kattrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::HardSigmoidAttrs => {
                if let Some(x) = self.attrs_as_hard_sigmoid_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::TriluAttrs => {
                if let Some(x) = self.attrs_as_trilu_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ScatterNDAttrs => {
                if let Some(x) = self.attrs_as_scatter_ndattrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::NonMaxSuppressionAttrs => {
                if let Some(x) = self.attrs_as_non_max_suppression_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::LayerNormalizationAttrs => {
                if let Some(x) = self.attrs_as_layer_normalization_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::RandomUniformAttrs => {
                if let Some(x) = self.attrs_as_random_uniform_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::EluAttrs => {
                if let Some(x) = self.attrs_as_elu_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::RandomUniformLikeAttrs => {
                if let Some(x) = self.attrs_as_random_uniform_like_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::RandomNormalAttrs => {
                if let Some(x) = self.attrs_as_random_normal_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::RandomNormalLikeAttrs => {
                if let Some(x) = self.attrs_as_random_normal_like_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::GatherNDAttrs => {
                if let Some(x) = self.attrs_as_gather_ndattrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::GeluAttrs => {
                if let Some(x) = self.attrs_as_gelu_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::EinsumAttrs => {
                if let Some(x) = self.attrs_as_einsum_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::IfAttrs => {
                if let Some(x) = self.attrs_as_if_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::PadAttrs => {
                if let Some(x) = self.attrs_as_pad_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::DequantizeLinearAttrs => {
                if let Some(x) = self.attrs_as_dequantize_linear_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::QuantizeLinearAttrs => {
                if let Some(x) = self.attrs_as_quantize_linear_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::DepthToSpaceAttrs => {
                if let Some(x) = self.attrs_as_depth_to_space_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::CastLikeAttrs => {
                if let Some(x) = self.attrs_as_cast_like_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ShapeAttrs => {
                if let Some(x) = self.attrs_as_shape_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::DropoutAttrs => {
                if let Some(x) = self.attrs_as_dropout_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::EyeLikeAttrs => {
                if let Some(x) = self.attrs_as_eye_like_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::IsInfAttrs => {
                if let Some(x) = self.attrs_as_is_inf_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("attrs", &x)
            }
        };
        ds.field("inputs", &self.inputs());
        ds.field("outputs", &self.outputs());
        ds.finish()
    }
}
pub enum FloatDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FloatData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FloatData<'a> {
    type Inner = FloatData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> FloatData<'a> {
    pub const VT_DATA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FloatData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args FloatDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<FloatData<'bldr>> {
        let mut builder = FloatDataBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn data(&self) -> flatbuffers::Vector<'a, f32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    FloatData::VT_DATA,
                    None,
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for FloatData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "data",
                Self::VT_DATA,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct FloatDataArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
}
impl<'a> Default for FloatDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        FloatDataArgs {
            data: None, // required field
        }
    }
}

pub struct FloatDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FloatDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FloatData::VT_DATA, data);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FloatDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        FloatDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FloatData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, FloatData::VT_DATA, "data");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for FloatData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("FloatData");
        ds.field("data", &self.data());
        ds.finish()
    }
}
pub enum Int8DataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Int8Data<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Int8Data<'a> {
    type Inner = Int8Data<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Int8Data<'a> {
    pub const VT_DATA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Int8Data { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args Int8DataArgs<'args>,
    ) -> flatbuffers::WIPOffset<Int8Data<'bldr>> {
        let mut builder = Int8DataBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn data(&self) -> flatbuffers::Vector<'a, i8> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(
                    Int8Data::VT_DATA,
                    None,
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for Int8Data<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i8>>>(
                "data",
                Self::VT_DATA,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct Int8DataArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i8>>>,
}
impl<'a> Default for Int8DataArgs<'a> {
    #[inline]
    fn default() -> Self {
        Int8DataArgs {
            data: None, // required field
        }
    }
}

pub struct Int8DataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Int8DataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Int8Data::VT_DATA, data);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Int8DataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        Int8DataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Int8Data<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, Int8Data::VT_DATA, "data");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Int8Data<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Int8Data");
        ds.field("data", &self.data());
        ds.finish()
    }
}
pub enum Int32DataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Int32Data<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Int32Data<'a> {
    type Inner = Int32Data<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Int32Data<'a> {
    pub const VT_DATA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Int32Data { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args Int32DataArgs<'args>,
    ) -> flatbuffers::WIPOffset<Int32Data<'bldr>> {
        let mut builder = Int32DataBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn data(&self) -> flatbuffers::Vector<'a, i32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    Int32Data::VT_DATA,
                    None,
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for Int32Data<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "data",
                Self::VT_DATA,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct Int32DataArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for Int32DataArgs<'a> {
    #[inline]
    fn default() -> Self {
        Int32DataArgs {
            data: None, // required field
        }
    }
}

pub struct Int32DataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> Int32DataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Int32Data::VT_DATA, data);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> Int32DataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        Int32DataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Int32Data<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, Int32Data::VT_DATA, "data");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Int32Data<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Int32Data");
        ds.field("data", &self.data());
        ds.finish()
    }
}
pub enum UInt8DataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UInt8Data<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UInt8Data<'a> {
    type Inner = UInt8Data<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> UInt8Data<'a> {
    pub const VT_DATA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        UInt8Data { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args UInt8DataArgs<'args>,
    ) -> flatbuffers::WIPOffset<UInt8Data<'bldr>> {
        let mut builder = UInt8DataBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn data(&self) -> flatbuffers::Vector<'a, u8> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    UInt8Data::VT_DATA,
                    None,
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for UInt8Data<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "data",
                Self::VT_DATA,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct UInt8DataArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for UInt8DataArgs<'a> {
    #[inline]
    fn default() -> Self {
        UInt8DataArgs {
            data: None, // required field
        }
    }
}

pub struct UInt8DataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UInt8DataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(UInt8Data::VT_DATA, data);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> UInt8DataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        UInt8DataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<UInt8Data<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, UInt8Data::VT_DATA, "data");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for UInt8Data<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("UInt8Data");
        ds.field("data", &self.data());
        ds.finish()
    }
}
pub enum ConstantNodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConstantNode<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConstantNode<'a> {
    type Inner = ConstantNode<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ConstantNode<'a> {
    pub const VT_SHAPE: flatbuffers::VOffsetT = 4;
    pub const VT_DATA_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_DATA: flatbuffers::VOffsetT = 8;
    pub const VT_DTYPE: flatbuffers::VOffsetT = 10;
    pub const VT_DATA_OFFSET: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConstantNode { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ConstantNodeArgs<'args>,
    ) -> flatbuffers::WIPOffset<ConstantNode<'bldr>> {
        let mut builder = ConstantNodeBuilder::new(_fbb);
        if let Some(x) = args.data_offset {
            builder.add_data_offset(x);
        }
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        if let Some(x) = args.shape {
            builder.add_shape(x);
        }
        if let Some(x) = args.dtype {
            builder.add_dtype(x);
        }
        builder.add_data_type(args.data_type);
        builder.finish()
    }

    #[inline]
    pub fn shape(&self) -> flatbuffers::Vector<'a, u32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    ConstantNode::VT_SHAPE,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn data_type(&self) -> ConstantData {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<ConstantData>(ConstantNode::VT_DATA_TYPE, Some(ConstantData::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn data(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ConstantNode::VT_DATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn dtype(&self) -> Option<ConstantDataType> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<ConstantDataType>(ConstantNode::VT_DTYPE, None)
        }
    }
    #[inline]
    pub fn data_offset(&self) -> Option<u64> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u64>(ConstantNode::VT_DATA_OFFSET, None) }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_float_data(&self) -> Option<FloatData<'a>> {
        if self.data_type() == ConstantData::FloatData {
            self.data().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { FloatData::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_int_32_data(&self) -> Option<Int32Data<'a>> {
        if self.data_type() == ConstantData::Int32Data {
            self.data().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { Int32Data::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_int_8_data(&self) -> Option<Int8Data<'a>> {
        if self.data_type() == ConstantData::Int8Data {
            self.data().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { Int8Data::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_uint_8_data(&self) -> Option<UInt8Data<'a>> {
        if self.data_type() == ConstantData::UInt8Data {
            self.data().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { UInt8Data::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for ConstantNode<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "shape",
                Self::VT_SHAPE,
                true,
            )?
            .visit_union::<ConstantData, _>(
                "data_type",
                Self::VT_DATA_TYPE,
                "data",
                Self::VT_DATA,
                false,
                |key, v, pos| match key {
                    ConstantData::FloatData => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<FloatData>>(
                            "ConstantData::FloatData",
                            pos,
                        ),
                    ConstantData::Int32Data => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<Int32Data>>(
                            "ConstantData::Int32Data",
                            pos,
                        ),
                    ConstantData::Int8Data => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<Int8Data>>(
                            "ConstantData::Int8Data",
                            pos,
                        ),
                    ConstantData::UInt8Data => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<UInt8Data>>(
                            "ConstantData::UInt8Data",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .visit_field::<ConstantDataType>("dtype", Self::VT_DTYPE, false)?
            .visit_field::<u64>("data_offset", Self::VT_DATA_OFFSET, false)?
            .finish();
        Ok(())
    }
}
pub struct ConstantNodeArgs<'a> {
    pub shape: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub data_type: ConstantData,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub dtype: Option<ConstantDataType>,
    pub data_offset: Option<u64>,
}
impl<'a> Default for ConstantNodeArgs<'a> {
    #[inline]
    fn default() -> Self {
        ConstantNodeArgs {
            shape: None, // required field
            data_type: ConstantData::NONE,
            data: None,
            dtype: None,
            data_offset: None,
        }
    }
}

pub struct ConstantNodeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ConstantNodeBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_shape(&mut self, shape: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ConstantNode::VT_SHAPE, shape);
    }
    #[inline]
    pub fn add_data_type(&mut self, data_type: ConstantData) {
        self.fbb_.push_slot::<ConstantData>(
            ConstantNode::VT_DATA_TYPE,
            data_type,
            ConstantData::NONE,
        );
    }
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ConstantNode::VT_DATA, data);
    }
    #[inline]
    pub fn add_dtype(&mut self, dtype: ConstantDataType) {
        self.fbb_
            .push_slot_always::<ConstantDataType>(ConstantNode::VT_DTYPE, dtype);
    }
    #[inline]
    pub fn add_data_offset(&mut self, data_offset: u64) {
        self.fbb_
            .push_slot_always::<u64>(ConstantNode::VT_DATA_OFFSET, data_offset);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ConstantNodeBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ConstantNodeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ConstantNode<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, ConstantNode::VT_SHAPE, "shape");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ConstantNode<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ConstantNode");
        ds.field("shape", &self.shape());
        ds.field("data_type", &self.data_type());
        match self.data_type() {
            ConstantData::FloatData => {
                if let Some(x) = self.data_as_float_data() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ConstantData::Int32Data => {
                if let Some(x) = self.data_as_int_32_data() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ConstantData::Int8Data => {
                if let Some(x) = self.data_as_int_8_data() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ConstantData::UInt8Data => {
                if let Some(x) = self.data_as_uint_8_data() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("data", &x)
            }
        };
        ds.field("dtype", &self.dtype());
        ds.field("data_offset", &self.data_offset());
        ds.finish()
    }
}
pub enum DimOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Dim<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Dim<'a> {
    type Inner = Dim<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Dim<'a> {
    pub const VT_VALUE: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Dim { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args DimArgs<'args>,
    ) -> flatbuffers::WIPOffset<Dim<'bldr>> {
        let mut builder = DimBuilder::new(_fbb);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_value(args.value);
        builder.finish()
    }

    #[inline]
    pub fn value(&self) -> u32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u32>(Dim::VT_VALUE, Some(0)).unwrap() }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Dim::VT_NAME, None)
        }
    }
}

impl flatbuffers::Verifiable for Dim<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u32>("value", Self::VT_VALUE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .finish();
        Ok(())
    }
}
pub struct DimArgs<'a> {
    pub value: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DimArgs<'a> {
    #[inline]
    fn default() -> Self {
        DimArgs {
            value: 0,
            name: None,
        }
    }
}

pub struct DimBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DimBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_value(&mut self, value: u32) {
        self.fbb_.push_slot::<u32>(Dim::VT_VALUE, value, 0);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Dim::VT_NAME, name);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DimBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        DimBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Dim<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Dim<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Dim");
        ds.field("value", &self.value());
        ds.field("name", &self.name());
        ds.finish()
    }
}
pub enum ValueNodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ValueNode<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ValueNode<'a> {
    type Inner = ValueNode<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ValueNode<'a> {
    pub const VT_SHAPE: flatbuffers::VOffsetT = 4;
    pub const VT_DTYPE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ValueNode { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ValueNodeArgs<'args>,
    ) -> flatbuffers::WIPOffset<ValueNode<'bldr>> {
        let mut builder = ValueNodeBuilder::new(_fbb);
        if let Some(x) = args.shape {
            builder.add_shape(x);
        }
        if let Some(x) = args.dtype {
            builder.add_dtype(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn shape(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Dim<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Dim>>,
            >>(ValueNode::VT_SHAPE, None)
        }
    }
    #[inline]
    pub fn dtype(&self) -> Option<DataType> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<DataType>(ValueNode::VT_DTYPE, None) }
    }
}

impl flatbuffers::Verifiable for ValueNode<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Dim>>,
            >>("shape", Self::VT_SHAPE, false)?
            .visit_field::<DataType>("dtype", Self::VT_DTYPE, false)?
            .finish();
        Ok(())
    }
}
pub struct ValueNodeArgs<'a> {
    pub shape: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Dim<'a>>>>,
    >,
    pub dtype: Option<DataType>,
}
impl<'a> Default for ValueNodeArgs<'a> {
    #[inline]
    fn default() -> Self {
        ValueNodeArgs {
            shape: None,
            dtype: None,
        }
    }
}

pub struct ValueNodeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ValueNodeBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_shape(
        &mut self,
        shape: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Dim<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ValueNode::VT_SHAPE, shape);
    }
    #[inline]
    pub fn add_dtype(&mut self, dtype: DataType) {
        self.fbb_
            .push_slot_always::<DataType>(ValueNode::VT_DTYPE, dtype);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ValueNodeBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ValueNodeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ValueNode<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ValueNode<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ValueNode");
        ds.field("shape", &self.shape());
        ds.field("dtype", &self.dtype());
        ds.finish()
    }
}
pub enum NodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Node<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Node<'a> {
    type Inner = Node<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Node<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_DATA_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_DATA: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Node { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args NodeArgs<'args>,
    ) -> flatbuffers::WIPOffset<Node<'bldr>> {
        let mut builder = NodeBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_data_type(args.data_type);
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Node::VT_NAME, None)
        }
    }
    #[inline]
    pub fn data_type(&self) -> NodeKind {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<NodeKind>(Node::VT_DATA_TYPE, Some(NodeKind::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn data(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Node::VT_DATA, None)
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_operator_node(&self) -> Option<OperatorNode<'a>> {
        if self.data_type() == NodeKind::OperatorNode {
            self.data().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { OperatorNode::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_constant_node(&self) -> Option<ConstantNode<'a>> {
        if self.data_type() == NodeKind::ConstantNode {
            self.data().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ConstantNode::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_value_node(&self) -> Option<ValueNode<'a>> {
        if self.data_type() == NodeKind::ValueNode {
            self.data().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ValueNode::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for Node<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_union::<NodeKind, _>(
                "data_type",
                Self::VT_DATA_TYPE,
                "data",
                Self::VT_DATA,
                false,
                |key, v, pos| match key {
                    NodeKind::OperatorNode => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<OperatorNode>>(
                            "NodeKind::OperatorNode",
                            pos,
                        ),
                    NodeKind::ConstantNode => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<ConstantNode>>(
                            "NodeKind::ConstantNode",
                            pos,
                        ),
                    NodeKind::ValueNode => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<ValueNode>>(
                            "NodeKind::ValueNode",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct NodeArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data_type: NodeKind,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for NodeArgs<'a> {
    #[inline]
    fn default() -> Self {
        NodeArgs {
            name: None,
            data_type: NodeKind::NONE,
            data: None,
        }
    }
}

pub struct NodeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NodeBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_NAME, name);
    }
    #[inline]
    pub fn add_data_type(&mut self, data_type: NodeKind) {
        self.fbb_
            .push_slot::<NodeKind>(Node::VT_DATA_TYPE, data_type, NodeKind::NONE);
    }
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_DATA, data);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> NodeBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        NodeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Node<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Node<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Node");
        ds.field("name", &self.name());
        ds.field("data_type", &self.data_type());
        match self.data_type() {
            NodeKind::OperatorNode => {
                if let Some(x) = self.data_as_operator_node() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            NodeKind::ConstantNode => {
                if let Some(x) = self.data_as_constant_node() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            NodeKind::ValueNode => {
                if let Some(x) = self.data_as_value_node() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("data", &x)
            }
        };
        ds.finish()
    }
}
pub enum GraphOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Graph<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Graph<'a> {
    type Inner = Graph<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Graph<'a> {
    pub const VT_NODES: flatbuffers::VOffsetT = 4;
    pub const VT_INPUTS: flatbuffers::VOffsetT = 6;
    pub const VT_OUTPUTS: flatbuffers::VOffsetT = 8;
    pub const VT_CAPTURES: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Graph { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args GraphArgs<'args>,
    ) -> flatbuffers::WIPOffset<Graph<'bldr>> {
        let mut builder = GraphBuilder::new(_fbb);
        if let Some(x) = args.captures {
            builder.add_captures(x);
        }
        if let Some(x) = args.outputs {
            builder.add_outputs(x);
        }
        if let Some(x) = args.inputs {
            builder.add_inputs(x);
        }
        if let Some(x) = args.nodes {
            builder.add_nodes(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn nodes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node>>,
            >>(Graph::VT_NODES, None)
        }
    }
    #[inline]
    pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    Graph::VT_INPUTS,
                    None,
                )
        }
    }
    #[inline]
    pub fn outputs(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    Graph::VT_OUTPUTS,
                    None,
                )
        }
    }
    #[inline]
    pub fn captures(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    Graph::VT_CAPTURES,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for Graph<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Node>>,
            >>("nodes", Self::VT_NODES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "inputs",
                Self::VT_INPUTS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "outputs",
                Self::VT_OUTPUTS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "captures",
                Self::VT_CAPTURES,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct GraphArgs<'a> {
    pub nodes: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node<'a>>>>,
    >,
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub outputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub captures: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for GraphArgs<'a> {
    #[inline]
    fn default() -> Self {
        GraphArgs {
            nodes: None,
            inputs: None,
            outputs: None,
            captures: None,
        }
    }
}

pub struct GraphBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GraphBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_nodes(
        &mut self,
        nodes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Node<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Graph::VT_NODES, nodes);
    }
    #[inline]
    pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Graph::VT_INPUTS, inputs);
    }
    #[inline]
    pub fn add_outputs(&mut self, outputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Graph::VT_OUTPUTS, outputs);
    }
    #[inline]
    pub fn add_captures(&mut self, captures: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Graph::VT_CAPTURES, captures);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GraphBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        GraphBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Graph<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Graph<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Graph");
        ds.field("nodes", &self.nodes());
        ds.field("inputs", &self.inputs());
        ds.field("outputs", &self.outputs());
        ds.field("captures", &self.captures());
        ds.finish()
    }
}
pub enum MetadataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Metadata<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Metadata<'a> {
    type Inner = Metadata<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Metadata<'a> {
    pub const VT_ONNX_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
    pub const VT_LICENSE: flatbuffers::VOffsetT = 8;
    pub const VT_COMMIT: flatbuffers::VOffsetT = 10;
    pub const VT_CODE_REPOSITORY: flatbuffers::VOffsetT = 12;
    pub const VT_MODEL_REPOSITORY: flatbuffers::VOffsetT = 14;
    pub const VT_RUN_ID: flatbuffers::VOffsetT = 16;
    pub const VT_RUN_URL: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Metadata { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args MetadataArgs<'args>,
    ) -> flatbuffers::WIPOffset<Metadata<'bldr>> {
        let mut builder = MetadataBuilder::new(_fbb);
        if let Some(x) = args.run_url {
            builder.add_run_url(x);
        }
        if let Some(x) = args.run_id {
            builder.add_run_id(x);
        }
        if let Some(x) = args.model_repository {
            builder.add_model_repository(x);
        }
        if let Some(x) = args.code_repository {
            builder.add_code_repository(x);
        }
        if let Some(x) = args.commit {
            builder.add_commit(x);
        }
        if let Some(x) = args.license {
            builder.add_license(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.onnx_hash {
            builder.add_onnx_hash(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn onnx_hash(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Metadata::VT_ONNX_HASH, None)
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Metadata::VT_DESCRIPTION, None)
        }
    }
    #[inline]
    pub fn license(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Metadata::VT_LICENSE, None)
        }
    }
    #[inline]
    pub fn commit(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Metadata::VT_COMMIT, None)
        }
    }
    #[inline]
    pub fn code_repository(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Metadata::VT_CODE_REPOSITORY, None)
        }
    }
    #[inline]
    pub fn model_repository(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Metadata::VT_MODEL_REPOSITORY, None)
        }
    }
    #[inline]
    pub fn run_id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Metadata::VT_RUN_ID, None)
        }
    }
    #[inline]
    pub fn run_url(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Metadata::VT_RUN_URL, None)
        }
    }
}

impl flatbuffers::Verifiable for Metadata<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "onnx_hash",
                Self::VT_ONNX_HASH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("license", Self::VT_LICENSE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("commit", Self::VT_COMMIT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "code_repository",
                Self::VT_CODE_REPOSITORY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "model_repository",
                Self::VT_MODEL_REPOSITORY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("run_id", Self::VT_RUN_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("run_url", Self::VT_RUN_URL, false)?
            .finish();
        Ok(())
    }
}
pub struct MetadataArgs<'a> {
    pub onnx_hash: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub license: Option<flatbuffers::WIPOffset<&'a str>>,
    pub commit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub code_repository: Option<flatbuffers::WIPOffset<&'a str>>,
    pub model_repository: Option<flatbuffers::WIPOffset<&'a str>>,
    pub run_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub run_url: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MetadataArgs<'a> {
    #[inline]
    fn default() -> Self {
        MetadataArgs {
            onnx_hash: None,
            description: None,
            license: None,
            commit: None,
            code_repository: None,
            model_repository: None,
            run_id: None,
            run_url: None,
        }
    }
}

pub struct MetadataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MetadataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_onnx_hash(&mut self, onnx_hash: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Metadata::VT_ONNX_HASH, onnx_hash);
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Metadata::VT_DESCRIPTION, description);
    }
    #[inline]
    pub fn add_license(&mut self, license: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Metadata::VT_LICENSE, license);
    }
    #[inline]
    pub fn add_commit(&mut self, commit: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Metadata::VT_COMMIT, commit);
    }
    #[inline]
    pub fn add_code_repository(&mut self, code_repository: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Metadata::VT_CODE_REPOSITORY,
            code_repository,
        );
    }
    #[inline]
    pub fn add_model_repository(&mut self, model_repository: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Metadata::VT_MODEL_REPOSITORY,
            model_repository,
        );
    }
    #[inline]
    pub fn add_run_id(&mut self, run_id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Metadata::VT_RUN_ID, run_id);
    }
    #[inline]
    pub fn add_run_url(&mut self, run_url: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Metadata::VT_RUN_URL, run_url);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MetadataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        MetadataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Metadata<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Metadata<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Metadata");
        ds.field("onnx_hash", &self.onnx_hash());
        ds.field("description", &self.description());
        ds.field("license", &self.license());
        ds.field("commit", &self.commit());
        ds.field("code_repository", &self.code_repository());
        ds.field("model_repository", &self.model_repository());
        ds.field("run_id", &self.run_id());
        ds.field("run_url", &self.run_url());
        ds.finish()
    }
}
pub enum ModelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Model<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Model<'a> {
    type Inner = Model<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Model<'a> {
    pub const VT_SCHEMA_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_GRAPH: flatbuffers::VOffsetT = 6;
    pub const VT_METADATA: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Model { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ModelArgs<'args>,
    ) -> flatbuffers::WIPOffset<Model<'bldr>> {
        let mut builder = ModelBuilder::new(_fbb);
        if let Some(x) = args.metadata {
            builder.add_metadata(x);
        }
        if let Some(x) = args.graph {
            builder.add_graph(x);
        }
        builder.add_schema_version(args.schema_version);
        builder.finish()
    }

    #[inline]
    pub fn schema_version(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(Model::VT_SCHEMA_VERSION, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn graph(&self) -> Graph<'a> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Graph>>(Model::VT_GRAPH, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn metadata(&self) -> Option<Metadata<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Metadata>>(Model::VT_METADATA, None)
        }
    }
}

impl flatbuffers::Verifiable for Model<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("schema_version", Self::VT_SCHEMA_VERSION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<Graph>>("graph", Self::VT_GRAPH, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<Metadata>>(
                "metadata",
                Self::VT_METADATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ModelArgs<'a> {
    pub schema_version: i32,
    pub graph: Option<flatbuffers::WIPOffset<Graph<'a>>>,
    pub metadata: Option<flatbuffers::WIPOffset<Metadata<'a>>>,
}
impl<'a> Default for ModelArgs<'a> {
    #[inline]
    fn default() -> Self {
        ModelArgs {
            schema_version: 0,
            graph: None, // required field
            metadata: None,
        }
    }
}

pub struct ModelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ModelBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_schema_version(&mut self, schema_version: i32) {
        self.fbb_
            .push_slot::<i32>(Model::VT_SCHEMA_VERSION, schema_version, 0);
    }
    #[inline]
    pub fn add_graph(&mut self, graph: flatbuffers::WIPOffset<Graph<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Graph>>(Model::VT_GRAPH, graph);
    }
    #[inline]
    pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<Metadata<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Metadata>>(Model::VT_METADATA, metadata);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ModelBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ModelBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Model<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, Model::VT_GRAPH, "graph");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Model<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Model");
        ds.field("schema_version", &self.schema_version());
        ds.field("graph", &self.graph());
        ds.field("metadata", &self.metadata());
        ds.finish()
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Model`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_model_unchecked`.
pub fn root_as_model(buf: &[u8]) -> Result<Model, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<Model>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Model` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_model_unchecked`.
pub fn size_prefixed_root_as_model(buf: &[u8]) -> Result<Model, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<Model>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Model` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_model_unchecked`.
pub fn root_as_model_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<Model<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<Model<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Model` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_model_unchecked`.
pub fn size_prefixed_root_as_model_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<Model<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<Model<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Model and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Model`.
pub unsafe fn root_as_model_unchecked(buf: &[u8]) -> Model {
    flatbuffers::root_unchecked::<Model>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Model and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Model`.
pub unsafe fn size_prefixed_root_as_model_unchecked(buf: &[u8]) -> Model {
    flatbuffers::size_prefixed_root_unchecked::<Model>(buf)
}
pub const MODEL_IDENTIFIER: &str = "RTEN";

#[inline]
pub fn model_buffer_has_identifier(buf: &[u8]) -> bool {
    flatbuffers::buffer_has_identifier(buf, MODEL_IDENTIFIER, false)
}

#[inline]
pub fn model_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
    flatbuffers::buffer_has_identifier(buf, MODEL_IDENTIFIER, true)
}

pub const MODEL_EXTENSION: &str = "rten";

#[inline]
pub fn finish_model_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Model<'a>>,
) {
    fbb.finish(root, Some(MODEL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_model_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Model<'a>>,
) {
    fbb.finish_size_prefixed(root, Some(MODEL_IDENTIFIER));
}
