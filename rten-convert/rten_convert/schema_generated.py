# automatically generated by the FlatBuffers compiler, do not modify

# namespace:

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class OperatorType(object):
    Add = 0
    ArgMin = 1
    ArgMax = 2
    AveragePool = 3
    BatchNormalization = 4
    Cast = 5
    Clip = 6
    Concat = 7
    ConstantOfShape = 8
    Conv = 9
    ConvTranspose = 10
    Cos = 11
    CumSum = 12
    Div = 13
    Equal = 14
    Erf = 15
    Expand = 16
    Flatten = 17
    Gather = 18
    Gemm = 19
    GlobalAveragePool = 20
    Greater = 21
    GRU = 22
    Identity = 23
    LeakyRelu = 24
    Less = 25
    LessOrEqual = 26
    Log = 27
    LogSoftmax = 28
    LSTM = 29
    MatMul = 30
    MaxPool = 31
    Mod = 32
    Mul = 33
    Pad = 34
    Pow = 35
    Range = 36
    ReduceMean = 37
    ReduceL2 = 38
    Relu = 39
    Reshape = 40
    Resize = 41
    Shape = 42
    Sigmoid = 43
    Sin = 44
    Slice = 45
    Split = 46
    Sqrt = 47
    Squeeze = 48
    Softmax = 49
    Sub = 50
    Tanh = 51
    Transpose = 52
    Unsqueeze = 53
    Where = 54
    ReduceProd = 55
    ReduceSum = 56
    ReduceMin = 57
    ReduceMax = 58
    NonZero = 59
    ScatterElements = 60
    Tile = 61
    Not = 62
    Abs = 63
    Max = 64
    Mean = 65
    Min = 66
    Sum = 67
    OneHot = 68
    Round = 69
    Floor = 70
    Ceil = 71
    Reciprocal = 72
    TopK = 73
    Neg = 74
    Exp = 75
    GreaterOrEqual = 76
    Size = 77
    Tan = 78
    Acos = 79
    Asin = 80
    Atan = 81
    InstanceNormalization = 82
    HardSigmoid = 83
    HardSwish = 84
    And = 85
    Or = 86
    Xor = 87
    Trilu = 88
    ScatterND = 89
    NonMaxSuppression = 90
    Sign = 91
    GatherElements = 92
    LayerNormalization = 93


class RNNDirection(object):
    Forwards = 0
    Reverse = 1
    Bidirectional = 2


class PadMode(object):
    Same = 0
    Fixed = 1


class DataType(object):
    Int32 = 0
    Float = 1


class CoordTransformMode(object):
    HalfPixel = 0
    Asymmetric = 1
    AlignCorners = 2


class NearestMode(object):
    Floor = 0
    Ceil = 1
    RoundPreferFloor = 2
    RoundPreferCeil = 3


class ResizeMode(object):
    Nearest = 0
    Linear = 1


class OperatorAttrs(object):
    NONE = 0
    ArgMaxAttrs = 1
    AveragePoolAttrs = 2
    BatchNormalizationAttrs = 3
    CastAttrs = 4
    ConcatAttrs = 5
    ConstantOfShapeAttrs = 6
    ConvAttrs = 7
    ConvTransposeAttrs = 8
    FlattenAttrs = 9
    GatherAttrs = 10
    GemmAttrs = 11
    GRUAttrs = 12
    LeakyReluAttrs = 13
    LSTMAttrs = 14
    MaxPoolAttrs = 15
    ReduceMeanAttrs = 16
    ReshapeAttrs = 17
    ResizeAttrs = 18
    SplitAttrs = 19
    SoftmaxAttrs = 20
    TransposeAttrs = 21
    ModAttrs = 22
    ScatterElementsAttrs = 23
    OneHotAttrs = 24
    TopKAttrs = 25
    HardSigmoidAttrs = 26
    TriluAttrs = 27
    ScatterNDAttrs = 28
    NonMaxSuppressionAttrs = 29
    LayerNormalizationAttrs = 30

def OperatorAttrsCreator(unionType, table):
    from flatbuffers.table import Table
    if not isinstance(table, Table):
        return None
    if unionType == OperatorAttrs().ArgMaxAttrs:
        return ArgMaxAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().AveragePoolAttrs:
        return AveragePoolAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().BatchNormalizationAttrs:
        return BatchNormalizationAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().CastAttrs:
        return CastAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().ConcatAttrs:
        return ConcatAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().ConstantOfShapeAttrs:
        return ConstantOfShapeAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().ConvAttrs:
        return ConvAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().ConvTransposeAttrs:
        return ConvTransposeAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().FlattenAttrs:
        return FlattenAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().GatherAttrs:
        return GatherAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().GemmAttrs:
        return GemmAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().GRUAttrs:
        return GRUAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().LeakyReluAttrs:
        return LeakyReluAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().LSTMAttrs:
        return LSTMAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().MaxPoolAttrs:
        return MaxPoolAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().ReduceMeanAttrs:
        return ReduceMeanAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().ReshapeAttrs:
        return ReshapeAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().ResizeAttrs:
        return ResizeAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().SplitAttrs:
        return SplitAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().SoftmaxAttrs:
        return SoftmaxAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().TransposeAttrs:
        return TransposeAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().ModAttrs:
        return ModAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().ScatterElementsAttrs:
        return ScatterElementsAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().OneHotAttrs:
        return OneHotAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().TopKAttrs:
        return TopKAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().HardSigmoidAttrs:
        return HardSigmoidAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().TriluAttrs:
        return TriluAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().ScatterNDAttrs:
        return ScatterNDAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().NonMaxSuppressionAttrs:
        return NonMaxSuppressionAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().LayerNormalizationAttrs:
        return LayerNormalizationAttrsT.InitFromBuf(table.Bytes, table.Pos)
    return None


class Scalar(object):
    NONE = 0
    IntScalar = 1
    FloatScalar = 2

def ScalarCreator(unionType, table):
    from flatbuffers.table import Table
    if not isinstance(table, Table):
        return None
    if unionType == Scalar().IntScalar:
        return IntScalarT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == Scalar().FloatScalar:
        return FloatScalarT.InitFromBuf(table.Bytes, table.Pos)
    return None


class NMSBoxOrder(object):
    TopLeftBottomRight = 0
    CenterWidthHeight = 1


class ScatterReduction(object):
    None_ = 0
    Add = 1
    Mul = 2
    Min = 3
    Max = 4


class NodeKind(object):
    NONE = 0
    OperatorNode = 1
    ConstantNode = 2
    ValueNode = 3

def NodeKindCreator(unionType, table):
    from flatbuffers.table import Table
    if not isinstance(table, Table):
        return None
    if unionType == NodeKind().OperatorNode:
        return OperatorNodeT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == NodeKind().ConstantNode:
        return ConstantNodeT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == NodeKind().ValueNode:
        return ValueNodeT.InitFromBuf(table.Bytes, table.Pos)
    return None


class ConstantData(object):
    NONE = 0
    FloatData = 1
    IntData = 2

def ConstantDataCreator(unionType, table):
    from flatbuffers.table import Table
    if not isinstance(table, Table):
        return None
    if unionType == ConstantData().FloatData:
        return FloatDataT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == ConstantData().IntData:
        return IntDataT.InitFromBuf(table.Bytes, table.Pos)
    return None


class ArgMaxAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ArgMaxAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsArgMaxAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ArgMaxAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # ArgMaxAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ArgMaxAttrs
    def Axis(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # ArgMaxAttrs
    def KeepDims(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

def ArgMaxAttrsStart(builder):
    builder.StartObject(2)

def ArgMaxAttrsAddAxis(builder, axis):
    builder.PrependInt32Slot(0, axis, 0)

def ArgMaxAttrsAddKeepDims(builder, keepDims):
    builder.PrependBoolSlot(1, keepDims, 0)

def ArgMaxAttrsEnd(builder):
    return builder.EndObject()



class ArgMaxAttrsT(object):

    # ArgMaxAttrsT
    def __init__(self):
        self.axis = 0  # type: int
        self.keepDims = False  # type: bool

    @classmethod
    def InitFromBuf(cls, buf, pos):
        argMaxAttrs = ArgMaxAttrs()
        argMaxAttrs.Init(buf, pos)
        return cls.InitFromObj(argMaxAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, argMaxAttrs):
        x = ArgMaxAttrsT()
        x._UnPack(argMaxAttrs)
        return x

    # ArgMaxAttrsT
    def _UnPack(self, argMaxAttrs):
        if argMaxAttrs is None:
            return
        self.axis = argMaxAttrs.Axis()
        self.keepDims = argMaxAttrs.KeepDims()

    # ArgMaxAttrsT
    def Pack(self, builder):
        ArgMaxAttrsStart(builder)
        ArgMaxAttrsAddAxis(builder, self.axis)
        ArgMaxAttrsAddKeepDims(builder, self.keepDims)
        argMaxAttrs = ArgMaxAttrsEnd(builder)
        return argMaxAttrs


class AveragePoolAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = AveragePoolAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsAveragePoolAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def AveragePoolAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # AveragePoolAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # AveragePoolAttrs
    def KernelSize(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # AveragePoolAttrs
    def KernelSizeAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # AveragePoolAttrs
    def KernelSizeLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # AveragePoolAttrs
    def KernelSizeIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # AveragePoolAttrs
    def PadMode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # AveragePoolAttrs
    def Pads(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # AveragePoolAttrs
    def PadsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # AveragePoolAttrs
    def PadsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # AveragePoolAttrs
    def PadsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # AveragePoolAttrs
    def Strides(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # AveragePoolAttrs
    def StridesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # AveragePoolAttrs
    def StridesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # AveragePoolAttrs
    def StridesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # AveragePoolAttrs
    def CountIncludePad(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

def AveragePoolAttrsStart(builder):
    builder.StartObject(5)

def AveragePoolAttrsAddKernelSize(builder, kernelSize):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(kernelSize), 0)

def AveragePoolAttrsStartKernelSizeVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def AveragePoolAttrsAddPadMode(builder, padMode):
    builder.PrependInt8Slot(1, padMode, 0)

def AveragePoolAttrsAddPads(builder, pads):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(pads), 0)

def AveragePoolAttrsStartPadsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def AveragePoolAttrsAddStrides(builder, strides):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(strides), 0)

def AveragePoolAttrsStartStridesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def AveragePoolAttrsAddCountIncludePad(builder, countIncludePad):
    builder.PrependBoolSlot(4, countIncludePad, 0)

def AveragePoolAttrsEnd(builder):
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class AveragePoolAttrsT(object):

    # AveragePoolAttrsT
    def __init__(self):
        self.kernelSize = None  # type: List[int]
        self.padMode = 0  # type: int
        self.pads = None  # type: List[int]
        self.strides = None  # type: List[int]
        self.countIncludePad = False  # type: bool

    @classmethod
    def InitFromBuf(cls, buf, pos):
        averagePoolAttrs = AveragePoolAttrs()
        averagePoolAttrs.Init(buf, pos)
        return cls.InitFromObj(averagePoolAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, averagePoolAttrs):
        x = AveragePoolAttrsT()
        x._UnPack(averagePoolAttrs)
        return x

    # AveragePoolAttrsT
    def _UnPack(self, averagePoolAttrs):
        if averagePoolAttrs is None:
            return
        if not averagePoolAttrs.KernelSizeIsNone():
            if np is None:
                self.kernelSize = []
                for i in range(averagePoolAttrs.KernelSizeLength()):
                    self.kernelSize.append(averagePoolAttrs.KernelSize(i))
            else:
                self.kernelSize = averagePoolAttrs.KernelSizeAsNumpy()
        self.padMode = averagePoolAttrs.PadMode()
        if not averagePoolAttrs.PadsIsNone():
            if np is None:
                self.pads = []
                for i in range(averagePoolAttrs.PadsLength()):
                    self.pads.append(averagePoolAttrs.Pads(i))
            else:
                self.pads = averagePoolAttrs.PadsAsNumpy()
        if not averagePoolAttrs.StridesIsNone():
            if np is None:
                self.strides = []
                for i in range(averagePoolAttrs.StridesLength()):
                    self.strides.append(averagePoolAttrs.Strides(i))
            else:
                self.strides = averagePoolAttrs.StridesAsNumpy()
        self.countIncludePad = averagePoolAttrs.CountIncludePad()

    # AveragePoolAttrsT
    def Pack(self, builder):
        if self.kernelSize is not None:
            if np is not None and type(self.kernelSize) is np.ndarray:
                kernelSize = builder.CreateNumpyVector(self.kernelSize)
            else:
                AveragePoolAttrsStartKernelSizeVector(builder, len(self.kernelSize))
                for i in reversed(range(len(self.kernelSize))):
                    builder.PrependUint32(self.kernelSize[i])
                kernelSize = builder.EndVector()
        if self.pads is not None:
            if np is not None and type(self.pads) is np.ndarray:
                pads = builder.CreateNumpyVector(self.pads)
            else:
                AveragePoolAttrsStartPadsVector(builder, len(self.pads))
                for i in reversed(range(len(self.pads))):
                    builder.PrependUint32(self.pads[i])
                pads = builder.EndVector()
        if self.strides is not None:
            if np is not None and type(self.strides) is np.ndarray:
                strides = builder.CreateNumpyVector(self.strides)
            else:
                AveragePoolAttrsStartStridesVector(builder, len(self.strides))
                for i in reversed(range(len(self.strides))):
                    builder.PrependUint32(self.strides[i])
                strides = builder.EndVector()
        AveragePoolAttrsStart(builder)
        if self.kernelSize is not None:
            AveragePoolAttrsAddKernelSize(builder, kernelSize)
        AveragePoolAttrsAddPadMode(builder, self.padMode)
        if self.pads is not None:
            AveragePoolAttrsAddPads(builder, pads)
        if self.strides is not None:
            AveragePoolAttrsAddStrides(builder, strides)
        AveragePoolAttrsAddCountIncludePad(builder, self.countIncludePad)
        averagePoolAttrs = AveragePoolAttrsEnd(builder)
        return averagePoolAttrs


class BatchNormalizationAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = BatchNormalizationAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsBatchNormalizationAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def BatchNormalizationAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # BatchNormalizationAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # BatchNormalizationAttrs
    def Epsilon(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

def BatchNormalizationAttrsStart(builder):
    builder.StartObject(1)

def BatchNormalizationAttrsAddEpsilon(builder, epsilon):
    builder.PrependFloat32Slot(0, epsilon, 0.0)

def BatchNormalizationAttrsEnd(builder):
    return builder.EndObject()



class BatchNormalizationAttrsT(object):

    # BatchNormalizationAttrsT
    def __init__(self):
        self.epsilon = 0.0  # type: float

    @classmethod
    def InitFromBuf(cls, buf, pos):
        batchNormalizationAttrs = BatchNormalizationAttrs()
        batchNormalizationAttrs.Init(buf, pos)
        return cls.InitFromObj(batchNormalizationAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, batchNormalizationAttrs):
        x = BatchNormalizationAttrsT()
        x._UnPack(batchNormalizationAttrs)
        return x

    # BatchNormalizationAttrsT
    def _UnPack(self, batchNormalizationAttrs):
        if batchNormalizationAttrs is None:
            return
        self.epsilon = batchNormalizationAttrs.Epsilon()

    # BatchNormalizationAttrsT
    def Pack(self, builder):
        BatchNormalizationAttrsStart(builder)
        BatchNormalizationAttrsAddEpsilon(builder, self.epsilon)
        batchNormalizationAttrs = BatchNormalizationAttrsEnd(builder)
        return batchNormalizationAttrs


class CastAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = CastAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsCastAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def CastAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # CastAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # CastAttrs
    def To(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

def CastAttrsStart(builder):
    builder.StartObject(1)

def CastAttrsAddTo(builder, to):
    builder.PrependInt8Slot(0, to, 0)

def CastAttrsEnd(builder):
    return builder.EndObject()



class CastAttrsT(object):

    # CastAttrsT
    def __init__(self):
        self.to = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        castAttrs = CastAttrs()
        castAttrs.Init(buf, pos)
        return cls.InitFromObj(castAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, castAttrs):
        x = CastAttrsT()
        x._UnPack(castAttrs)
        return x

    # CastAttrsT
    def _UnPack(self, castAttrs):
        if castAttrs is None:
            return
        self.to = castAttrs.To()

    # CastAttrsT
    def Pack(self, builder):
        CastAttrsStart(builder)
        CastAttrsAddTo(builder, self.to)
        castAttrs = CastAttrsEnd(builder)
        return castAttrs


class ConcatAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ConcatAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsConcatAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ConcatAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # ConcatAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ConcatAttrs
    def Axis(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

def ConcatAttrsStart(builder):
    builder.StartObject(1)

def ConcatAttrsAddAxis(builder, axis):
    builder.PrependInt32Slot(0, axis, 0)

def ConcatAttrsEnd(builder):
    return builder.EndObject()



class ConcatAttrsT(object):

    # ConcatAttrsT
    def __init__(self):
        self.axis = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        concatAttrs = ConcatAttrs()
        concatAttrs.Init(buf, pos)
        return cls.InitFromObj(concatAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, concatAttrs):
        x = ConcatAttrsT()
        x._UnPack(concatAttrs)
        return x

    # ConcatAttrsT
    def _UnPack(self, concatAttrs):
        if concatAttrs is None:
            return
        self.axis = concatAttrs.Axis()

    # ConcatAttrsT
    def Pack(self, builder):
        ConcatAttrsStart(builder)
        ConcatAttrsAddAxis(builder, self.axis)
        concatAttrs = ConcatAttrsEnd(builder)
        return concatAttrs


class IntScalar(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = IntScalar()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsIntScalar(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def IntScalarBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # IntScalar
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # IntScalar
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

def IntScalarStart(builder):
    builder.StartObject(1)

def IntScalarAddValue(builder, value):
    builder.PrependInt32Slot(0, value, 0)

def IntScalarEnd(builder):
    return builder.EndObject()



class IntScalarT(object):

    # IntScalarT
    def __init__(self):
        self.value = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        intScalar = IntScalar()
        intScalar.Init(buf, pos)
        return cls.InitFromObj(intScalar)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, intScalar):
        x = IntScalarT()
        x._UnPack(intScalar)
        return x

    # IntScalarT
    def _UnPack(self, intScalar):
        if intScalar is None:
            return
        self.value = intScalar.Value()

    # IntScalarT
    def Pack(self, builder):
        IntScalarStart(builder)
        IntScalarAddValue(builder, self.value)
        intScalar = IntScalarEnd(builder)
        return intScalar


class FloatScalar(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = FloatScalar()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsFloatScalar(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def FloatScalarBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # FloatScalar
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # FloatScalar
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

def FloatScalarStart(builder):
    builder.StartObject(1)

def FloatScalarAddValue(builder, value):
    builder.PrependFloat32Slot(0, value, 0.0)

def FloatScalarEnd(builder):
    return builder.EndObject()



class FloatScalarT(object):

    # FloatScalarT
    def __init__(self):
        self.value = 0.0  # type: float

    @classmethod
    def InitFromBuf(cls, buf, pos):
        floatScalar = FloatScalar()
        floatScalar.Init(buf, pos)
        return cls.InitFromObj(floatScalar)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, floatScalar):
        x = FloatScalarT()
        x._UnPack(floatScalar)
        return x

    # FloatScalarT
    def _UnPack(self, floatScalar):
        if floatScalar is None:
            return
        self.value = floatScalar.Value()

    # FloatScalarT
    def Pack(self, builder):
        FloatScalarStart(builder)
        FloatScalarAddValue(builder, self.value)
        floatScalar = FloatScalarEnd(builder)
        return floatScalar


class ConstantOfShapeAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ConstantOfShapeAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsConstantOfShapeAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ConstantOfShapeAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # ConstantOfShapeAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ConstantOfShapeAttrs
    def ValueType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # ConstantOfShapeAttrs
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            from flatbuffers.table import Table
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

def ConstantOfShapeAttrsStart(builder):
    builder.StartObject(2)

def ConstantOfShapeAttrsAddValueType(builder, valueType):
    builder.PrependUint8Slot(0, valueType, 0)

def ConstantOfShapeAttrsAddValue(builder, value):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(value), 0)

def ConstantOfShapeAttrsEnd(builder):
    return builder.EndObject()


try:
    from typing import Union
except:
    pass

class ConstantOfShapeAttrsT(object):

    # ConstantOfShapeAttrsT
    def __init__(self):
        self.valueType = 0  # type: int
        self.value = None  # type: Union[None, IntScalarT, FloatScalarT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        constantOfShapeAttrs = ConstantOfShapeAttrs()
        constantOfShapeAttrs.Init(buf, pos)
        return cls.InitFromObj(constantOfShapeAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, constantOfShapeAttrs):
        x = ConstantOfShapeAttrsT()
        x._UnPack(constantOfShapeAttrs)
        return x

    # ConstantOfShapeAttrsT
    def _UnPack(self, constantOfShapeAttrs):
        if constantOfShapeAttrs is None:
            return
        self.valueType = constantOfShapeAttrs.ValueType()
        self.value = ScalarCreator(self.valueType, constantOfShapeAttrs.Value())

    # ConstantOfShapeAttrsT
    def Pack(self, builder):
        if self.value is not None:
            value = self.value.Pack(builder)
        ConstantOfShapeAttrsStart(builder)
        ConstantOfShapeAttrsAddValueType(builder, self.valueType)
        if self.value is not None:
            ConstantOfShapeAttrsAddValue(builder, value)
        constantOfShapeAttrs = ConstantOfShapeAttrsEnd(builder)
        return constantOfShapeAttrs


class ConvAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ConvAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsConvAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ConvAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # ConvAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ConvAttrs
    def PadMode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # ConvAttrs
    def Pads(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # ConvAttrs
    def PadsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # ConvAttrs
    def PadsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ConvAttrs
    def PadsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # ConvAttrs
    def Groups(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # ConvAttrs
    def Strides(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # ConvAttrs
    def StridesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # ConvAttrs
    def StridesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ConvAttrs
    def StridesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # ConvAttrs
    def Dilations(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # ConvAttrs
    def DilationsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # ConvAttrs
    def DilationsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ConvAttrs
    def DilationsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

def ConvAttrsStart(builder):
    builder.StartObject(5)

def ConvAttrsAddPadMode(builder, padMode):
    builder.PrependInt8Slot(0, padMode, 0)

def ConvAttrsAddPads(builder, pads):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(pads), 0)

def ConvAttrsStartPadsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def ConvAttrsAddGroups(builder, groups):
    builder.PrependUint32Slot(2, groups, 0)

def ConvAttrsAddStrides(builder, strides):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(strides), 0)

def ConvAttrsStartStridesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def ConvAttrsAddDilations(builder, dilations):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(dilations), 0)

def ConvAttrsStartDilationsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def ConvAttrsEnd(builder):
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class ConvAttrsT(object):

    # ConvAttrsT
    def __init__(self):
        self.padMode = 0  # type: int
        self.pads = None  # type: List[int]
        self.groups = 0  # type: int
        self.strides = None  # type: List[int]
        self.dilations = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        convAttrs = ConvAttrs()
        convAttrs.Init(buf, pos)
        return cls.InitFromObj(convAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, convAttrs):
        x = ConvAttrsT()
        x._UnPack(convAttrs)
        return x

    # ConvAttrsT
    def _UnPack(self, convAttrs):
        if convAttrs is None:
            return
        self.padMode = convAttrs.PadMode()
        if not convAttrs.PadsIsNone():
            if np is None:
                self.pads = []
                for i in range(convAttrs.PadsLength()):
                    self.pads.append(convAttrs.Pads(i))
            else:
                self.pads = convAttrs.PadsAsNumpy()
        self.groups = convAttrs.Groups()
        if not convAttrs.StridesIsNone():
            if np is None:
                self.strides = []
                for i in range(convAttrs.StridesLength()):
                    self.strides.append(convAttrs.Strides(i))
            else:
                self.strides = convAttrs.StridesAsNumpy()
        if not convAttrs.DilationsIsNone():
            if np is None:
                self.dilations = []
                for i in range(convAttrs.DilationsLength()):
                    self.dilations.append(convAttrs.Dilations(i))
            else:
                self.dilations = convAttrs.DilationsAsNumpy()

    # ConvAttrsT
    def Pack(self, builder):
        if self.pads is not None:
            if np is not None and type(self.pads) is np.ndarray:
                pads = builder.CreateNumpyVector(self.pads)
            else:
                ConvAttrsStartPadsVector(builder, len(self.pads))
                for i in reversed(range(len(self.pads))):
                    builder.PrependUint32(self.pads[i])
                pads = builder.EndVector()
        if self.strides is not None:
            if np is not None and type(self.strides) is np.ndarray:
                strides = builder.CreateNumpyVector(self.strides)
            else:
                ConvAttrsStartStridesVector(builder, len(self.strides))
                for i in reversed(range(len(self.strides))):
                    builder.PrependUint32(self.strides[i])
                strides = builder.EndVector()
        if self.dilations is not None:
            if np is not None and type(self.dilations) is np.ndarray:
                dilations = builder.CreateNumpyVector(self.dilations)
            else:
                ConvAttrsStartDilationsVector(builder, len(self.dilations))
                for i in reversed(range(len(self.dilations))):
                    builder.PrependUint32(self.dilations[i])
                dilations = builder.EndVector()
        ConvAttrsStart(builder)
        ConvAttrsAddPadMode(builder, self.padMode)
        if self.pads is not None:
            ConvAttrsAddPads(builder, pads)
        ConvAttrsAddGroups(builder, self.groups)
        if self.strides is not None:
            ConvAttrsAddStrides(builder, strides)
        if self.dilations is not None:
            ConvAttrsAddDilations(builder, dilations)
        convAttrs = ConvAttrsEnd(builder)
        return convAttrs


class ConvTransposeAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ConvTransposeAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsConvTransposeAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ConvTransposeAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # ConvTransposeAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ConvTransposeAttrs
    def Strides(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # ConvTransposeAttrs
    def StridesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # ConvTransposeAttrs
    def StridesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ConvTransposeAttrs
    def StridesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

def ConvTransposeAttrsStart(builder):
    builder.StartObject(1)

def ConvTransposeAttrsAddStrides(builder, strides):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(strides), 0)

def ConvTransposeAttrsStartStridesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def ConvTransposeAttrsEnd(builder):
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class ConvTransposeAttrsT(object):

    # ConvTransposeAttrsT
    def __init__(self):
        self.strides = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        convTransposeAttrs = ConvTransposeAttrs()
        convTransposeAttrs.Init(buf, pos)
        return cls.InitFromObj(convTransposeAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, convTransposeAttrs):
        x = ConvTransposeAttrsT()
        x._UnPack(convTransposeAttrs)
        return x

    # ConvTransposeAttrsT
    def _UnPack(self, convTransposeAttrs):
        if convTransposeAttrs is None:
            return
        if not convTransposeAttrs.StridesIsNone():
            if np is None:
                self.strides = []
                for i in range(convTransposeAttrs.StridesLength()):
                    self.strides.append(convTransposeAttrs.Strides(i))
            else:
                self.strides = convTransposeAttrs.StridesAsNumpy()

    # ConvTransposeAttrsT
    def Pack(self, builder):
        if self.strides is not None:
            if np is not None and type(self.strides) is np.ndarray:
                strides = builder.CreateNumpyVector(self.strides)
            else:
                ConvTransposeAttrsStartStridesVector(builder, len(self.strides))
                for i in reversed(range(len(self.strides))):
                    builder.PrependUint32(self.strides[i])
                strides = builder.EndVector()
        ConvTransposeAttrsStart(builder)
        if self.strides is not None:
            ConvTransposeAttrsAddStrides(builder, strides)
        convTransposeAttrs = ConvTransposeAttrsEnd(builder)
        return convTransposeAttrs


class FlattenAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = FlattenAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsFlattenAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def FlattenAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # FlattenAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # FlattenAttrs
    def Axis(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

def FlattenAttrsStart(builder):
    builder.StartObject(1)

def FlattenAttrsAddAxis(builder, axis):
    builder.PrependInt32Slot(0, axis, 0)

def FlattenAttrsEnd(builder):
    return builder.EndObject()



class FlattenAttrsT(object):

    # FlattenAttrsT
    def __init__(self):
        self.axis = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        flattenAttrs = FlattenAttrs()
        flattenAttrs.Init(buf, pos)
        return cls.InitFromObj(flattenAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, flattenAttrs):
        x = FlattenAttrsT()
        x._UnPack(flattenAttrs)
        return x

    # FlattenAttrsT
    def _UnPack(self, flattenAttrs):
        if flattenAttrs is None:
            return
        self.axis = flattenAttrs.Axis()

    # FlattenAttrsT
    def Pack(self, builder):
        FlattenAttrsStart(builder)
        FlattenAttrsAddAxis(builder, self.axis)
        flattenAttrs = FlattenAttrsEnd(builder)
        return flattenAttrs


class LayerNormalizationAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = LayerNormalizationAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsLayerNormalizationAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def LayerNormalizationAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # LayerNormalizationAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # LayerNormalizationAttrs
    def Axis(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # LayerNormalizationAttrs
    def Epsilon(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

def LayerNormalizationAttrsStart(builder):
    builder.StartObject(2)

def LayerNormalizationAttrsAddAxis(builder, axis):
    builder.PrependInt32Slot(0, axis, 0)

def LayerNormalizationAttrsAddEpsilon(builder, epsilon):
    builder.PrependFloat32Slot(1, epsilon, 0.0)

def LayerNormalizationAttrsEnd(builder):
    return builder.EndObject()



class LayerNormalizationAttrsT(object):

    # LayerNormalizationAttrsT
    def __init__(self):
        self.axis = 0  # type: int
        self.epsilon = 0.0  # type: float

    @classmethod
    def InitFromBuf(cls, buf, pos):
        layerNormalizationAttrs = LayerNormalizationAttrs()
        layerNormalizationAttrs.Init(buf, pos)
        return cls.InitFromObj(layerNormalizationAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, layerNormalizationAttrs):
        x = LayerNormalizationAttrsT()
        x._UnPack(layerNormalizationAttrs)
        return x

    # LayerNormalizationAttrsT
    def _UnPack(self, layerNormalizationAttrs):
        if layerNormalizationAttrs is None:
            return
        self.axis = layerNormalizationAttrs.Axis()
        self.epsilon = layerNormalizationAttrs.Epsilon()

    # LayerNormalizationAttrsT
    def Pack(self, builder):
        LayerNormalizationAttrsStart(builder)
        LayerNormalizationAttrsAddAxis(builder, self.axis)
        LayerNormalizationAttrsAddEpsilon(builder, self.epsilon)
        layerNormalizationAttrs = LayerNormalizationAttrsEnd(builder)
        return layerNormalizationAttrs


class GatherAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = GatherAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsGatherAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def GatherAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # GatherAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # GatherAttrs
    def Axis(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

def GatherAttrsStart(builder):
    builder.StartObject(1)

def GatherAttrsAddAxis(builder, axis):
    builder.PrependInt32Slot(0, axis, 0)

def GatherAttrsEnd(builder):
    return builder.EndObject()



class GatherAttrsT(object):

    # GatherAttrsT
    def __init__(self):
        self.axis = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        gatherAttrs = GatherAttrs()
        gatherAttrs.Init(buf, pos)
        return cls.InitFromObj(gatherAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, gatherAttrs):
        x = GatherAttrsT()
        x._UnPack(gatherAttrs)
        return x

    # GatherAttrsT
    def _UnPack(self, gatherAttrs):
        if gatherAttrs is None:
            return
        self.axis = gatherAttrs.Axis()

    # GatherAttrsT
    def Pack(self, builder):
        GatherAttrsStart(builder)
        GatherAttrsAddAxis(builder, self.axis)
        gatherAttrs = GatherAttrsEnd(builder)
        return gatherAttrs


class GemmAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = GemmAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsGemmAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def GemmAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # GemmAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # GemmAttrs
    def Alpha(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # GemmAttrs
    def Beta(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # GemmAttrs
    def TransposeA(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # GemmAttrs
    def TransposeB(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

def GemmAttrsStart(builder):
    builder.StartObject(4)

def GemmAttrsAddAlpha(builder, alpha):
    builder.PrependFloat32Slot(0, alpha, 0.0)

def GemmAttrsAddBeta(builder, beta):
    builder.PrependFloat32Slot(1, beta, 0.0)

def GemmAttrsAddTransposeA(builder, transposeA):
    builder.PrependBoolSlot(2, transposeA, 0)

def GemmAttrsAddTransposeB(builder, transposeB):
    builder.PrependBoolSlot(3, transposeB, 0)

def GemmAttrsEnd(builder):
    return builder.EndObject()



class GemmAttrsT(object):

    # GemmAttrsT
    def __init__(self):
        self.alpha = 0.0  # type: float
        self.beta = 0.0  # type: float
        self.transposeA = False  # type: bool
        self.transposeB = False  # type: bool

    @classmethod
    def InitFromBuf(cls, buf, pos):
        gemmAttrs = GemmAttrs()
        gemmAttrs.Init(buf, pos)
        return cls.InitFromObj(gemmAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, gemmAttrs):
        x = GemmAttrsT()
        x._UnPack(gemmAttrs)
        return x

    # GemmAttrsT
    def _UnPack(self, gemmAttrs):
        if gemmAttrs is None:
            return
        self.alpha = gemmAttrs.Alpha()
        self.beta = gemmAttrs.Beta()
        self.transposeA = gemmAttrs.TransposeA()
        self.transposeB = gemmAttrs.TransposeB()

    # GemmAttrsT
    def Pack(self, builder):
        GemmAttrsStart(builder)
        GemmAttrsAddAlpha(builder, self.alpha)
        GemmAttrsAddBeta(builder, self.beta)
        GemmAttrsAddTransposeA(builder, self.transposeA)
        GemmAttrsAddTransposeB(builder, self.transposeB)
        gemmAttrs = GemmAttrsEnd(builder)
        return gemmAttrs


class GRUAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = GRUAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsGRUAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def GRUAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # GRUAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # GRUAttrs
    def Direction(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # GRUAttrs
    def HiddenSize(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # GRUAttrs
    def LinearBeforeReset(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

def GRUAttrsStart(builder):
    builder.StartObject(3)

def GRUAttrsAddDirection(builder, direction):
    builder.PrependInt8Slot(0, direction, 0)

def GRUAttrsAddHiddenSize(builder, hiddenSize):
    builder.PrependUint32Slot(1, hiddenSize, 0)

def GRUAttrsAddLinearBeforeReset(builder, linearBeforeReset):
    builder.PrependBoolSlot(2, linearBeforeReset, 0)

def GRUAttrsEnd(builder):
    return builder.EndObject()



class GRUAttrsT(object):

    # GRUAttrsT
    def __init__(self):
        self.direction = 0  # type: int
        self.hiddenSize = 0  # type: int
        self.linearBeforeReset = False  # type: bool

    @classmethod
    def InitFromBuf(cls, buf, pos):
        gruattrs = GRUAttrs()
        gruattrs.Init(buf, pos)
        return cls.InitFromObj(gruattrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, gruattrs):
        x = GRUAttrsT()
        x._UnPack(gruattrs)
        return x

    # GRUAttrsT
    def _UnPack(self, gruattrs):
        if gruattrs is None:
            return
        self.direction = gruattrs.Direction()
        self.hiddenSize = gruattrs.HiddenSize()
        self.linearBeforeReset = gruattrs.LinearBeforeReset()

    # GRUAttrsT
    def Pack(self, builder):
        GRUAttrsStart(builder)
        GRUAttrsAddDirection(builder, self.direction)
        GRUAttrsAddHiddenSize(builder, self.hiddenSize)
        GRUAttrsAddLinearBeforeReset(builder, self.linearBeforeReset)
        gruattrs = GRUAttrsEnd(builder)
        return gruattrs


class HardSigmoidAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = HardSigmoidAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsHardSigmoidAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def HardSigmoidAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # HardSigmoidAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # HardSigmoidAttrs
    def Alpha(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # HardSigmoidAttrs
    def Beta(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

def HardSigmoidAttrsStart(builder):
    builder.StartObject(2)

def HardSigmoidAttrsAddAlpha(builder, alpha):
    builder.PrependFloat32Slot(0, alpha, 0.0)

def HardSigmoidAttrsAddBeta(builder, beta):
    builder.PrependFloat32Slot(1, beta, 0.0)

def HardSigmoidAttrsEnd(builder):
    return builder.EndObject()



class HardSigmoidAttrsT(object):

    # HardSigmoidAttrsT
    def __init__(self):
        self.alpha = 0.0  # type: float
        self.beta = 0.0  # type: float

    @classmethod
    def InitFromBuf(cls, buf, pos):
        hardSigmoidAttrs = HardSigmoidAttrs()
        hardSigmoidAttrs.Init(buf, pos)
        return cls.InitFromObj(hardSigmoidAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, hardSigmoidAttrs):
        x = HardSigmoidAttrsT()
        x._UnPack(hardSigmoidAttrs)
        return x

    # HardSigmoidAttrsT
    def _UnPack(self, hardSigmoidAttrs):
        if hardSigmoidAttrs is None:
            return
        self.alpha = hardSigmoidAttrs.Alpha()
        self.beta = hardSigmoidAttrs.Beta()

    # HardSigmoidAttrsT
    def Pack(self, builder):
        HardSigmoidAttrsStart(builder)
        HardSigmoidAttrsAddAlpha(builder, self.alpha)
        HardSigmoidAttrsAddBeta(builder, self.beta)
        hardSigmoidAttrs = HardSigmoidAttrsEnd(builder)
        return hardSigmoidAttrs


class LeakyReluAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = LeakyReluAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsLeakyReluAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def LeakyReluAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # LeakyReluAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # LeakyReluAttrs
    def Alpha(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

def LeakyReluAttrsStart(builder):
    builder.StartObject(1)

def LeakyReluAttrsAddAlpha(builder, alpha):
    builder.PrependFloat32Slot(0, alpha, 0.0)

def LeakyReluAttrsEnd(builder):
    return builder.EndObject()



class LeakyReluAttrsT(object):

    # LeakyReluAttrsT
    def __init__(self):
        self.alpha = 0.0  # type: float

    @classmethod
    def InitFromBuf(cls, buf, pos):
        leakyReluAttrs = LeakyReluAttrs()
        leakyReluAttrs.Init(buf, pos)
        return cls.InitFromObj(leakyReluAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, leakyReluAttrs):
        x = LeakyReluAttrsT()
        x._UnPack(leakyReluAttrs)
        return x

    # LeakyReluAttrsT
    def _UnPack(self, leakyReluAttrs):
        if leakyReluAttrs is None:
            return
        self.alpha = leakyReluAttrs.Alpha()

    # LeakyReluAttrsT
    def Pack(self, builder):
        LeakyReluAttrsStart(builder)
        LeakyReluAttrsAddAlpha(builder, self.alpha)
        leakyReluAttrs = LeakyReluAttrsEnd(builder)
        return leakyReluAttrs


class LSTMAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = LSTMAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsLSTMAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def LSTMAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # LSTMAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # LSTMAttrs
    def Direction(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # LSTMAttrs
    def HiddenSize(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def LSTMAttrsStart(builder):
    builder.StartObject(2)

def LSTMAttrsAddDirection(builder, direction):
    builder.PrependInt8Slot(0, direction, 0)

def LSTMAttrsAddHiddenSize(builder, hiddenSize):
    builder.PrependUint32Slot(1, hiddenSize, 0)

def LSTMAttrsEnd(builder):
    return builder.EndObject()



class LSTMAttrsT(object):

    # LSTMAttrsT
    def __init__(self):
        self.direction = 0  # type: int
        self.hiddenSize = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        lstmattrs = LSTMAttrs()
        lstmattrs.Init(buf, pos)
        return cls.InitFromObj(lstmattrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, lstmattrs):
        x = LSTMAttrsT()
        x._UnPack(lstmattrs)
        return x

    # LSTMAttrsT
    def _UnPack(self, lstmattrs):
        if lstmattrs is None:
            return
        self.direction = lstmattrs.Direction()
        self.hiddenSize = lstmattrs.HiddenSize()

    # LSTMAttrsT
    def Pack(self, builder):
        LSTMAttrsStart(builder)
        LSTMAttrsAddDirection(builder, self.direction)
        LSTMAttrsAddHiddenSize(builder, self.hiddenSize)
        lstmattrs = LSTMAttrsEnd(builder)
        return lstmattrs


class MaxPoolAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = MaxPoolAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMaxPoolAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def MaxPoolAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # MaxPoolAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # MaxPoolAttrs
    def KernelSize(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # MaxPoolAttrs
    def KernelSizeAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # MaxPoolAttrs
    def KernelSizeLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MaxPoolAttrs
    def KernelSizeIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # MaxPoolAttrs
    def PadMode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # MaxPoolAttrs
    def Pads(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # MaxPoolAttrs
    def PadsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # MaxPoolAttrs
    def PadsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MaxPoolAttrs
    def PadsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # MaxPoolAttrs
    def Strides(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # MaxPoolAttrs
    def StridesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # MaxPoolAttrs
    def StridesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MaxPoolAttrs
    def StridesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

def MaxPoolAttrsStart(builder):
    builder.StartObject(4)

def MaxPoolAttrsAddKernelSize(builder, kernelSize):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(kernelSize), 0)

def MaxPoolAttrsStartKernelSizeVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def MaxPoolAttrsAddPadMode(builder, padMode):
    builder.PrependInt8Slot(1, padMode, 0)

def MaxPoolAttrsAddPads(builder, pads):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(pads), 0)

def MaxPoolAttrsStartPadsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def MaxPoolAttrsAddStrides(builder, strides):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(strides), 0)

def MaxPoolAttrsStartStridesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def MaxPoolAttrsEnd(builder):
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class MaxPoolAttrsT(object):

    # MaxPoolAttrsT
    def __init__(self):
        self.kernelSize = None  # type: List[int]
        self.padMode = 0  # type: int
        self.pads = None  # type: List[int]
        self.strides = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        maxPoolAttrs = MaxPoolAttrs()
        maxPoolAttrs.Init(buf, pos)
        return cls.InitFromObj(maxPoolAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, maxPoolAttrs):
        x = MaxPoolAttrsT()
        x._UnPack(maxPoolAttrs)
        return x

    # MaxPoolAttrsT
    def _UnPack(self, maxPoolAttrs):
        if maxPoolAttrs is None:
            return
        if not maxPoolAttrs.KernelSizeIsNone():
            if np is None:
                self.kernelSize = []
                for i in range(maxPoolAttrs.KernelSizeLength()):
                    self.kernelSize.append(maxPoolAttrs.KernelSize(i))
            else:
                self.kernelSize = maxPoolAttrs.KernelSizeAsNumpy()
        self.padMode = maxPoolAttrs.PadMode()
        if not maxPoolAttrs.PadsIsNone():
            if np is None:
                self.pads = []
                for i in range(maxPoolAttrs.PadsLength()):
                    self.pads.append(maxPoolAttrs.Pads(i))
            else:
                self.pads = maxPoolAttrs.PadsAsNumpy()
        if not maxPoolAttrs.StridesIsNone():
            if np is None:
                self.strides = []
                for i in range(maxPoolAttrs.StridesLength()):
                    self.strides.append(maxPoolAttrs.Strides(i))
            else:
                self.strides = maxPoolAttrs.StridesAsNumpy()

    # MaxPoolAttrsT
    def Pack(self, builder):
        if self.kernelSize is not None:
            if np is not None and type(self.kernelSize) is np.ndarray:
                kernelSize = builder.CreateNumpyVector(self.kernelSize)
            else:
                MaxPoolAttrsStartKernelSizeVector(builder, len(self.kernelSize))
                for i in reversed(range(len(self.kernelSize))):
                    builder.PrependUint32(self.kernelSize[i])
                kernelSize = builder.EndVector()
        if self.pads is not None:
            if np is not None and type(self.pads) is np.ndarray:
                pads = builder.CreateNumpyVector(self.pads)
            else:
                MaxPoolAttrsStartPadsVector(builder, len(self.pads))
                for i in reversed(range(len(self.pads))):
                    builder.PrependUint32(self.pads[i])
                pads = builder.EndVector()
        if self.strides is not None:
            if np is not None and type(self.strides) is np.ndarray:
                strides = builder.CreateNumpyVector(self.strides)
            else:
                MaxPoolAttrsStartStridesVector(builder, len(self.strides))
                for i in reversed(range(len(self.strides))):
                    builder.PrependUint32(self.strides[i])
                strides = builder.EndVector()
        MaxPoolAttrsStart(builder)
        if self.kernelSize is not None:
            MaxPoolAttrsAddKernelSize(builder, kernelSize)
        MaxPoolAttrsAddPadMode(builder, self.padMode)
        if self.pads is not None:
            MaxPoolAttrsAddPads(builder, pads)
        if self.strides is not None:
            MaxPoolAttrsAddStrides(builder, strides)
        maxPoolAttrs = MaxPoolAttrsEnd(builder)
        return maxPoolAttrs


class ModAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ModAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsModAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ModAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # ModAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ModAttrs
    def Fmod(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

def ModAttrsStart(builder):
    builder.StartObject(1)

def ModAttrsAddFmod(builder, fmod):
    builder.PrependBoolSlot(0, fmod, 0)

def ModAttrsEnd(builder):
    return builder.EndObject()



class ModAttrsT(object):

    # ModAttrsT
    def __init__(self):
        self.fmod = False  # type: bool

    @classmethod
    def InitFromBuf(cls, buf, pos):
        modAttrs = ModAttrs()
        modAttrs.Init(buf, pos)
        return cls.InitFromObj(modAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, modAttrs):
        x = ModAttrsT()
        x._UnPack(modAttrs)
        return x

    # ModAttrsT
    def _UnPack(self, modAttrs):
        if modAttrs is None:
            return
        self.fmod = modAttrs.Fmod()

    # ModAttrsT
    def Pack(self, builder):
        ModAttrsStart(builder)
        ModAttrsAddFmod(builder, self.fmod)
        modAttrs = ModAttrsEnd(builder)
        return modAttrs


class NonMaxSuppressionAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = NonMaxSuppressionAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsNonMaxSuppressionAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def NonMaxSuppressionAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # NonMaxSuppressionAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # NonMaxSuppressionAttrs
    def BoxOrder(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

def NonMaxSuppressionAttrsStart(builder):
    builder.StartObject(1)

def NonMaxSuppressionAttrsAddBoxOrder(builder, boxOrder):
    builder.PrependInt8Slot(0, boxOrder, 0)

def NonMaxSuppressionAttrsEnd(builder):
    return builder.EndObject()



class NonMaxSuppressionAttrsT(object):

    # NonMaxSuppressionAttrsT
    def __init__(self):
        self.boxOrder = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        nonMaxSuppressionAttrs = NonMaxSuppressionAttrs()
        nonMaxSuppressionAttrs.Init(buf, pos)
        return cls.InitFromObj(nonMaxSuppressionAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, nonMaxSuppressionAttrs):
        x = NonMaxSuppressionAttrsT()
        x._UnPack(nonMaxSuppressionAttrs)
        return x

    # NonMaxSuppressionAttrsT
    def _UnPack(self, nonMaxSuppressionAttrs):
        if nonMaxSuppressionAttrs is None:
            return
        self.boxOrder = nonMaxSuppressionAttrs.BoxOrder()

    # NonMaxSuppressionAttrsT
    def Pack(self, builder):
        NonMaxSuppressionAttrsStart(builder)
        NonMaxSuppressionAttrsAddBoxOrder(builder, self.boxOrder)
        nonMaxSuppressionAttrs = NonMaxSuppressionAttrsEnd(builder)
        return nonMaxSuppressionAttrs


class OneHotAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = OneHotAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsOneHotAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def OneHotAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # OneHotAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # OneHotAttrs
    def Axis(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

def OneHotAttrsStart(builder):
    builder.StartObject(1)

def OneHotAttrsAddAxis(builder, axis):
    builder.PrependInt32Slot(0, axis, 0)

def OneHotAttrsEnd(builder):
    return builder.EndObject()



class OneHotAttrsT(object):

    # OneHotAttrsT
    def __init__(self):
        self.axis = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        oneHotAttrs = OneHotAttrs()
        oneHotAttrs.Init(buf, pos)
        return cls.InitFromObj(oneHotAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, oneHotAttrs):
        x = OneHotAttrsT()
        x._UnPack(oneHotAttrs)
        return x

    # OneHotAttrsT
    def _UnPack(self, oneHotAttrs):
        if oneHotAttrs is None:
            return
        self.axis = oneHotAttrs.Axis()

    # OneHotAttrsT
    def Pack(self, builder):
        OneHotAttrsStart(builder)
        OneHotAttrsAddAxis(builder, self.axis)
        oneHotAttrs = OneHotAttrsEnd(builder)
        return oneHotAttrs


class ReduceMeanAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ReduceMeanAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsReduceMeanAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ReduceMeanAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # ReduceMeanAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ReduceMeanAttrs
    def Axes(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # ReduceMeanAttrs
    def AxesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # ReduceMeanAttrs
    def AxesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ReduceMeanAttrs
    def AxesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # ReduceMeanAttrs
    def KeepDims(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

def ReduceMeanAttrsStart(builder):
    builder.StartObject(2)

def ReduceMeanAttrsAddAxes(builder, axes):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(axes), 0)

def ReduceMeanAttrsStartAxesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def ReduceMeanAttrsAddKeepDims(builder, keepDims):
    builder.PrependBoolSlot(1, keepDims, 0)

def ReduceMeanAttrsEnd(builder):
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class ReduceMeanAttrsT(object):

    # ReduceMeanAttrsT
    def __init__(self):
        self.axes = None  # type: List[int]
        self.keepDims = False  # type: bool

    @classmethod
    def InitFromBuf(cls, buf, pos):
        reduceMeanAttrs = ReduceMeanAttrs()
        reduceMeanAttrs.Init(buf, pos)
        return cls.InitFromObj(reduceMeanAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, reduceMeanAttrs):
        x = ReduceMeanAttrsT()
        x._UnPack(reduceMeanAttrs)
        return x

    # ReduceMeanAttrsT
    def _UnPack(self, reduceMeanAttrs):
        if reduceMeanAttrs is None:
            return
        if not reduceMeanAttrs.AxesIsNone():
            if np is None:
                self.axes = []
                for i in range(reduceMeanAttrs.AxesLength()):
                    self.axes.append(reduceMeanAttrs.Axes(i))
            else:
                self.axes = reduceMeanAttrs.AxesAsNumpy()
        self.keepDims = reduceMeanAttrs.KeepDims()

    # ReduceMeanAttrsT
    def Pack(self, builder):
        if self.axes is not None:
            if np is not None and type(self.axes) is np.ndarray:
                axes = builder.CreateNumpyVector(self.axes)
            else:
                ReduceMeanAttrsStartAxesVector(builder, len(self.axes))
                for i in reversed(range(len(self.axes))):
                    builder.PrependInt32(self.axes[i])
                axes = builder.EndVector()
        ReduceMeanAttrsStart(builder)
        if self.axes is not None:
            ReduceMeanAttrsAddAxes(builder, axes)
        ReduceMeanAttrsAddKeepDims(builder, self.keepDims)
        reduceMeanAttrs = ReduceMeanAttrsEnd(builder)
        return reduceMeanAttrs


class ReshapeAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ReshapeAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsReshapeAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ReshapeAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # ReshapeAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ReshapeAttrs
    def AllowZero(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

def ReshapeAttrsStart(builder):
    builder.StartObject(1)

def ReshapeAttrsAddAllowZero(builder, allowZero):
    builder.PrependBoolSlot(0, allowZero, 0)

def ReshapeAttrsEnd(builder):
    return builder.EndObject()



class ReshapeAttrsT(object):

    # ReshapeAttrsT
    def __init__(self):
        self.allowZero = False  # type: bool

    @classmethod
    def InitFromBuf(cls, buf, pos):
        reshapeAttrs = ReshapeAttrs()
        reshapeAttrs.Init(buf, pos)
        return cls.InitFromObj(reshapeAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, reshapeAttrs):
        x = ReshapeAttrsT()
        x._UnPack(reshapeAttrs)
        return x

    # ReshapeAttrsT
    def _UnPack(self, reshapeAttrs):
        if reshapeAttrs is None:
            return
        self.allowZero = reshapeAttrs.AllowZero()

    # ReshapeAttrsT
    def Pack(self, builder):
        ReshapeAttrsStart(builder)
        ReshapeAttrsAddAllowZero(builder, self.allowZero)
        reshapeAttrs = ReshapeAttrsEnd(builder)
        return reshapeAttrs


class ResizeAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ResizeAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsResizeAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ResizeAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # ResizeAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ResizeAttrs
    def Mode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # ResizeAttrs
    def CoordMode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # ResizeAttrs
    def NearestMode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

def ResizeAttrsStart(builder):
    builder.StartObject(3)

def ResizeAttrsAddMode(builder, mode):
    builder.PrependInt8Slot(0, mode, 0)

def ResizeAttrsAddCoordMode(builder, coordMode):
    builder.PrependInt8Slot(1, coordMode, 0)

def ResizeAttrsAddNearestMode(builder, nearestMode):
    builder.PrependInt8Slot(2, nearestMode, 0)

def ResizeAttrsEnd(builder):
    return builder.EndObject()



class ResizeAttrsT(object):

    # ResizeAttrsT
    def __init__(self):
        self.mode = 0  # type: int
        self.coordMode = 0  # type: int
        self.nearestMode = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        resizeAttrs = ResizeAttrs()
        resizeAttrs.Init(buf, pos)
        return cls.InitFromObj(resizeAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, resizeAttrs):
        x = ResizeAttrsT()
        x._UnPack(resizeAttrs)
        return x

    # ResizeAttrsT
    def _UnPack(self, resizeAttrs):
        if resizeAttrs is None:
            return
        self.mode = resizeAttrs.Mode()
        self.coordMode = resizeAttrs.CoordMode()
        self.nearestMode = resizeAttrs.NearestMode()

    # ResizeAttrsT
    def Pack(self, builder):
        ResizeAttrsStart(builder)
        ResizeAttrsAddMode(builder, self.mode)
        ResizeAttrsAddCoordMode(builder, self.coordMode)
        ResizeAttrsAddNearestMode(builder, self.nearestMode)
        resizeAttrs = ResizeAttrsEnd(builder)
        return resizeAttrs


class ScatterElementsAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ScatterElementsAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsScatterElementsAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ScatterElementsAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # ScatterElementsAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ScatterElementsAttrs
    def Axis(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # ScatterElementsAttrs
    def Reduction(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

def ScatterElementsAttrsStart(builder):
    builder.StartObject(2)

def ScatterElementsAttrsAddAxis(builder, axis):
    builder.PrependInt32Slot(0, axis, 0)

def ScatterElementsAttrsAddReduction(builder, reduction):
    builder.PrependInt8Slot(1, reduction, 0)

def ScatterElementsAttrsEnd(builder):
    return builder.EndObject()



class ScatterElementsAttrsT(object):

    # ScatterElementsAttrsT
    def __init__(self):
        self.axis = 0  # type: int
        self.reduction = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        scatterElementsAttrs = ScatterElementsAttrs()
        scatterElementsAttrs.Init(buf, pos)
        return cls.InitFromObj(scatterElementsAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, scatterElementsAttrs):
        x = ScatterElementsAttrsT()
        x._UnPack(scatterElementsAttrs)
        return x

    # ScatterElementsAttrsT
    def _UnPack(self, scatterElementsAttrs):
        if scatterElementsAttrs is None:
            return
        self.axis = scatterElementsAttrs.Axis()
        self.reduction = scatterElementsAttrs.Reduction()

    # ScatterElementsAttrsT
    def Pack(self, builder):
        ScatterElementsAttrsStart(builder)
        ScatterElementsAttrsAddAxis(builder, self.axis)
        ScatterElementsAttrsAddReduction(builder, self.reduction)
        scatterElementsAttrs = ScatterElementsAttrsEnd(builder)
        return scatterElementsAttrs


class ScatterNDAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ScatterNDAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsScatterNDAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ScatterNDAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # ScatterNDAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ScatterNDAttrs
    def Reduction(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

def ScatterNDAttrsStart(builder):
    builder.StartObject(1)

def ScatterNDAttrsAddReduction(builder, reduction):
    builder.PrependInt8Slot(0, reduction, 0)

def ScatterNDAttrsEnd(builder):
    return builder.EndObject()



class ScatterNDAttrsT(object):

    # ScatterNDAttrsT
    def __init__(self):
        self.reduction = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        scatterNdattrs = ScatterNDAttrs()
        scatterNdattrs.Init(buf, pos)
        return cls.InitFromObj(scatterNdattrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, scatterNdattrs):
        x = ScatterNDAttrsT()
        x._UnPack(scatterNdattrs)
        return x

    # ScatterNDAttrsT
    def _UnPack(self, scatterNdattrs):
        if scatterNdattrs is None:
            return
        self.reduction = scatterNdattrs.Reduction()

    # ScatterNDAttrsT
    def Pack(self, builder):
        ScatterNDAttrsStart(builder)
        ScatterNDAttrsAddReduction(builder, self.reduction)
        scatterNdattrs = ScatterNDAttrsEnd(builder)
        return scatterNdattrs


class SoftmaxAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = SoftmaxAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSoftmaxAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def SoftmaxAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # SoftmaxAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # SoftmaxAttrs
    def Axis(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

def SoftmaxAttrsStart(builder):
    builder.StartObject(1)

def SoftmaxAttrsAddAxis(builder, axis):
    builder.PrependInt32Slot(0, axis, 0)

def SoftmaxAttrsEnd(builder):
    return builder.EndObject()



class SoftmaxAttrsT(object):

    # SoftmaxAttrsT
    def __init__(self):
        self.axis = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        softmaxAttrs = SoftmaxAttrs()
        softmaxAttrs.Init(buf, pos)
        return cls.InitFromObj(softmaxAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, softmaxAttrs):
        x = SoftmaxAttrsT()
        x._UnPack(softmaxAttrs)
        return x

    # SoftmaxAttrsT
    def _UnPack(self, softmaxAttrs):
        if softmaxAttrs is None:
            return
        self.axis = softmaxAttrs.Axis()

    # SoftmaxAttrsT
    def Pack(self, builder):
        SoftmaxAttrsStart(builder)
        SoftmaxAttrsAddAxis(builder, self.axis)
        softmaxAttrs = SoftmaxAttrsEnd(builder)
        return softmaxAttrs


class SplitAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = SplitAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSplitAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def SplitAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # SplitAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # SplitAttrs
    def Axis(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

def SplitAttrsStart(builder):
    builder.StartObject(1)

def SplitAttrsAddAxis(builder, axis):
    builder.PrependInt32Slot(0, axis, 0)

def SplitAttrsEnd(builder):
    return builder.EndObject()



class SplitAttrsT(object):

    # SplitAttrsT
    def __init__(self):
        self.axis = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        splitAttrs = SplitAttrs()
        splitAttrs.Init(buf, pos)
        return cls.InitFromObj(splitAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, splitAttrs):
        x = SplitAttrsT()
        x._UnPack(splitAttrs)
        return x

    # SplitAttrsT
    def _UnPack(self, splitAttrs):
        if splitAttrs is None:
            return
        self.axis = splitAttrs.Axis()

    # SplitAttrsT
    def Pack(self, builder):
        SplitAttrsStart(builder)
        SplitAttrsAddAxis(builder, self.axis)
        splitAttrs = SplitAttrsEnd(builder)
        return splitAttrs


class TopKAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = TopKAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsTopKAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def TopKAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # TopKAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # TopKAttrs
    def Axis(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # TopKAttrs
    def Largest(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # TopKAttrs
    def Sorted(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

def TopKAttrsStart(builder):
    builder.StartObject(3)

def TopKAttrsAddAxis(builder, axis):
    builder.PrependInt32Slot(0, axis, 0)

def TopKAttrsAddLargest(builder, largest):
    builder.PrependBoolSlot(1, largest, 0)

def TopKAttrsAddSorted(builder, sorted):
    builder.PrependBoolSlot(2, sorted, 0)

def TopKAttrsEnd(builder):
    return builder.EndObject()



class TopKAttrsT(object):

    # TopKAttrsT
    def __init__(self):
        self.axis = 0  # type: int
        self.largest = False  # type: bool
        self.sorted = False  # type: bool

    @classmethod
    def InitFromBuf(cls, buf, pos):
        topKattrs = TopKAttrs()
        topKattrs.Init(buf, pos)
        return cls.InitFromObj(topKattrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, topKattrs):
        x = TopKAttrsT()
        x._UnPack(topKattrs)
        return x

    # TopKAttrsT
    def _UnPack(self, topKattrs):
        if topKattrs is None:
            return
        self.axis = topKattrs.Axis()
        self.largest = topKattrs.Largest()
        self.sorted = topKattrs.Sorted()

    # TopKAttrsT
    def Pack(self, builder):
        TopKAttrsStart(builder)
        TopKAttrsAddAxis(builder, self.axis)
        TopKAttrsAddLargest(builder, self.largest)
        TopKAttrsAddSorted(builder, self.sorted)
        topKattrs = TopKAttrsEnd(builder)
        return topKattrs


class TransposeAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = TransposeAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsTransposeAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def TransposeAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # TransposeAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # TransposeAttrs
    def Perm(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # TransposeAttrs
    def PermAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # TransposeAttrs
    def PermLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # TransposeAttrs
    def PermIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

def TransposeAttrsStart(builder):
    builder.StartObject(1)

def TransposeAttrsAddPerm(builder, perm):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(perm), 0)

def TransposeAttrsStartPermVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def TransposeAttrsEnd(builder):
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class TransposeAttrsT(object):

    # TransposeAttrsT
    def __init__(self):
        self.perm = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        transposeAttrs = TransposeAttrs()
        transposeAttrs.Init(buf, pos)
        return cls.InitFromObj(transposeAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, transposeAttrs):
        x = TransposeAttrsT()
        x._UnPack(transposeAttrs)
        return x

    # TransposeAttrsT
    def _UnPack(self, transposeAttrs):
        if transposeAttrs is None:
            return
        if not transposeAttrs.PermIsNone():
            if np is None:
                self.perm = []
                for i in range(transposeAttrs.PermLength()):
                    self.perm.append(transposeAttrs.Perm(i))
            else:
                self.perm = transposeAttrs.PermAsNumpy()

    # TransposeAttrsT
    def Pack(self, builder):
        if self.perm is not None:
            if np is not None and type(self.perm) is np.ndarray:
                perm = builder.CreateNumpyVector(self.perm)
            else:
                TransposeAttrsStartPermVector(builder, len(self.perm))
                for i in reversed(range(len(self.perm))):
                    builder.PrependUint32(self.perm[i])
                perm = builder.EndVector()
        TransposeAttrsStart(builder)
        if self.perm is not None:
            TransposeAttrsAddPerm(builder, perm)
        transposeAttrs = TransposeAttrsEnd(builder)
        return transposeAttrs


class TriluAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = TriluAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsTriluAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def TriluAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # TriluAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # TriluAttrs
    def Upper(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

def TriluAttrsStart(builder):
    builder.StartObject(1)

def TriluAttrsAddUpper(builder, upper):
    builder.PrependBoolSlot(0, upper, 0)

def TriluAttrsEnd(builder):
    return builder.EndObject()



class TriluAttrsT(object):

    # TriluAttrsT
    def __init__(self):
        self.upper = False  # type: bool

    @classmethod
    def InitFromBuf(cls, buf, pos):
        triluAttrs = TriluAttrs()
        triluAttrs.Init(buf, pos)
        return cls.InitFromObj(triluAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, triluAttrs):
        x = TriluAttrsT()
        x._UnPack(triluAttrs)
        return x

    # TriluAttrsT
    def _UnPack(self, triluAttrs):
        if triluAttrs is None:
            return
        self.upper = triluAttrs.Upper()

    # TriluAttrsT
    def Pack(self, builder):
        TriluAttrsStart(builder)
        TriluAttrsAddUpper(builder, self.upper)
        triluAttrs = TriluAttrsEnd(builder)
        return triluAttrs


class OperatorNode(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = OperatorNode()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsOperatorNode(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def OperatorNodeBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # OperatorNode
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # OperatorNode
    def Type(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # OperatorNode
    def AttrsType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # OperatorNode
    def Attrs(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            from flatbuffers.table import Table
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

    # OperatorNode
    def Inputs(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # OperatorNode
    def InputsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # OperatorNode
    def InputsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # OperatorNode
    def InputsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # OperatorNode
    def Outputs(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # OperatorNode
    def OutputsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # OperatorNode
    def OutputsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # OperatorNode
    def OutputsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

def OperatorNodeStart(builder):
    builder.StartObject(5)

def OperatorNodeAddType(builder, type):
    builder.PrependInt8Slot(0, type, 0)

def OperatorNodeAddAttrsType(builder, attrsType):
    builder.PrependUint8Slot(1, attrsType, 0)

def OperatorNodeAddAttrs(builder, attrs):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(attrs), 0)

def OperatorNodeAddInputs(builder, inputs):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(inputs), 0)

def OperatorNodeStartInputsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def OperatorNodeAddOutputs(builder, outputs):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(outputs), 0)

def OperatorNodeStartOutputsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def OperatorNodeEnd(builder):
    return builder.EndObject()


try:
    from typing import List, Union
except:
    pass

class OperatorNodeT(object):

    # OperatorNodeT
    def __init__(self):
        self.type = 0  # type: int
        self.attrsType = 0  # type: int
        self.attrs = None  # type: Union[None, ArgMaxAttrsT, AveragePoolAttrsT, BatchNormalizationAttrsT, CastAttrsT, ConcatAttrsT, ConstantOfShapeAttrsT, ConvAttrsT, ConvTransposeAttrsT, FlattenAttrsT, GatherAttrsT, GemmAttrsT, GRUAttrsT, LeakyReluAttrsT, LSTMAttrsT, MaxPoolAttrsT, ReduceMeanAttrsT, ReshapeAttrsT, ResizeAttrsT, SplitAttrsT, SoftmaxAttrsT, TransposeAttrsT, ModAttrsT, ScatterElementsAttrsT, OneHotAttrsT, TopKAttrsT, HardSigmoidAttrsT, TriluAttrsT, ScatterNDAttrsT, NonMaxSuppressionAttrsT, LayerNormalizationAttrsT]
        self.inputs = None  # type: List[int]
        self.outputs = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        operatorNode = OperatorNode()
        operatorNode.Init(buf, pos)
        return cls.InitFromObj(operatorNode)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, operatorNode):
        x = OperatorNodeT()
        x._UnPack(operatorNode)
        return x

    # OperatorNodeT
    def _UnPack(self, operatorNode):
        if operatorNode is None:
            return
        self.type = operatorNode.Type()
        self.attrsType = operatorNode.AttrsType()
        self.attrs = OperatorAttrsCreator(self.attrsType, operatorNode.Attrs())
        if not operatorNode.InputsIsNone():
            if np is None:
                self.inputs = []
                for i in range(operatorNode.InputsLength()):
                    self.inputs.append(operatorNode.Inputs(i))
            else:
                self.inputs = operatorNode.InputsAsNumpy()
        if not operatorNode.OutputsIsNone():
            if np is None:
                self.outputs = []
                for i in range(operatorNode.OutputsLength()):
                    self.outputs.append(operatorNode.Outputs(i))
            else:
                self.outputs = operatorNode.OutputsAsNumpy()

    # OperatorNodeT
    def Pack(self, builder):
        if self.attrs is not None:
            attrs = self.attrs.Pack(builder)
        if self.inputs is not None:
            if np is not None and type(self.inputs) is np.ndarray:
                inputs = builder.CreateNumpyVector(self.inputs)
            else:
                OperatorNodeStartInputsVector(builder, len(self.inputs))
                for i in reversed(range(len(self.inputs))):
                    builder.PrependInt32(self.inputs[i])
                inputs = builder.EndVector()
        if self.outputs is not None:
            if np is not None and type(self.outputs) is np.ndarray:
                outputs = builder.CreateNumpyVector(self.outputs)
            else:
                OperatorNodeStartOutputsVector(builder, len(self.outputs))
                for i in reversed(range(len(self.outputs))):
                    builder.PrependInt32(self.outputs[i])
                outputs = builder.EndVector()
        OperatorNodeStart(builder)
        OperatorNodeAddType(builder, self.type)
        OperatorNodeAddAttrsType(builder, self.attrsType)
        if self.attrs is not None:
            OperatorNodeAddAttrs(builder, attrs)
        if self.inputs is not None:
            OperatorNodeAddInputs(builder, inputs)
        if self.outputs is not None:
            OperatorNodeAddOutputs(builder, outputs)
        operatorNode = OperatorNodeEnd(builder)
        return operatorNode


class FloatData(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = FloatData()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsFloatData(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def FloatDataBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # FloatData
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # FloatData
    def Data(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Float32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # FloatData
    def DataAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Float32Flags, o)
        return 0

    # FloatData
    def DataLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # FloatData
    def DataIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

def FloatDataStart(builder):
    builder.StartObject(1)

def FloatDataAddData(builder, data):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(data), 0)

def FloatDataStartDataVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def FloatDataEnd(builder):
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class FloatDataT(object):

    # FloatDataT
    def __init__(self):
        self.data = None  # type: List[float]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        floatData = FloatData()
        floatData.Init(buf, pos)
        return cls.InitFromObj(floatData)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, floatData):
        x = FloatDataT()
        x._UnPack(floatData)
        return x

    # FloatDataT
    def _UnPack(self, floatData):
        if floatData is None:
            return
        if not floatData.DataIsNone():
            if np is None:
                self.data = []
                for i in range(floatData.DataLength()):
                    self.data.append(floatData.Data(i))
            else:
                self.data = floatData.DataAsNumpy()

    # FloatDataT
    def Pack(self, builder):
        if self.data is not None:
            if np is not None and type(self.data) is np.ndarray:
                data = builder.CreateNumpyVector(self.data)
            else:
                FloatDataStartDataVector(builder, len(self.data))
                for i in reversed(range(len(self.data))):
                    builder.PrependFloat32(self.data[i])
                data = builder.EndVector()
        FloatDataStart(builder)
        if self.data is not None:
            FloatDataAddData(builder, data)
        floatData = FloatDataEnd(builder)
        return floatData


class IntData(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = IntData()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsIntData(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def IntDataBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # IntData
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # IntData
    def Data(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # IntData
    def DataAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # IntData
    def DataLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # IntData
    def DataIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

def IntDataStart(builder):
    builder.StartObject(1)

def IntDataAddData(builder, data):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(data), 0)

def IntDataStartDataVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def IntDataEnd(builder):
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class IntDataT(object):

    # IntDataT
    def __init__(self):
        self.data = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        intData = IntData()
        intData.Init(buf, pos)
        return cls.InitFromObj(intData)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, intData):
        x = IntDataT()
        x._UnPack(intData)
        return x

    # IntDataT
    def _UnPack(self, intData):
        if intData is None:
            return
        if not intData.DataIsNone():
            if np is None:
                self.data = []
                for i in range(intData.DataLength()):
                    self.data.append(intData.Data(i))
            else:
                self.data = intData.DataAsNumpy()

    # IntDataT
    def Pack(self, builder):
        if self.data is not None:
            if np is not None and type(self.data) is np.ndarray:
                data = builder.CreateNumpyVector(self.data)
            else:
                IntDataStartDataVector(builder, len(self.data))
                for i in reversed(range(len(self.data))):
                    builder.PrependInt32(self.data[i])
                data = builder.EndVector()
        IntDataStart(builder)
        if self.data is not None:
            IntDataAddData(builder, data)
        intData = IntDataEnd(builder)
        return intData


class ConstantNode(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ConstantNode()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsConstantNode(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ConstantNodeBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # ConstantNode
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ConstantNode
    def Shape(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # ConstantNode
    def ShapeAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # ConstantNode
    def ShapeLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ConstantNode
    def ShapeIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # ConstantNode
    def DataType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # ConstantNode
    def Data(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            from flatbuffers.table import Table
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

def ConstantNodeStart(builder):
    builder.StartObject(3)

def ConstantNodeAddShape(builder, shape):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(shape), 0)

def ConstantNodeStartShapeVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def ConstantNodeAddDataType(builder, dataType):
    builder.PrependUint8Slot(1, dataType, 0)

def ConstantNodeAddData(builder, data):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(data), 0)

def ConstantNodeEnd(builder):
    return builder.EndObject()


try:
    from typing import List, Union
except:
    pass

class ConstantNodeT(object):

    # ConstantNodeT
    def __init__(self):
        self.shape = None  # type: List[int]
        self.dataType = 0  # type: int
        self.data = None  # type: Union[None, FloatDataT, IntDataT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        constantNode = ConstantNode()
        constantNode.Init(buf, pos)
        return cls.InitFromObj(constantNode)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, constantNode):
        x = ConstantNodeT()
        x._UnPack(constantNode)
        return x

    # ConstantNodeT
    def _UnPack(self, constantNode):
        if constantNode is None:
            return
        if not constantNode.ShapeIsNone():
            if np is None:
                self.shape = []
                for i in range(constantNode.ShapeLength()):
                    self.shape.append(constantNode.Shape(i))
            else:
                self.shape = constantNode.ShapeAsNumpy()
        self.dataType = constantNode.DataType()
        self.data = ConstantDataCreator(self.dataType, constantNode.Data())

    # ConstantNodeT
    def Pack(self, builder):
        if self.shape is not None:
            if np is not None and type(self.shape) is np.ndarray:
                shape = builder.CreateNumpyVector(self.shape)
            else:
                ConstantNodeStartShapeVector(builder, len(self.shape))
                for i in reversed(range(len(self.shape))):
                    builder.PrependUint32(self.shape[i])
                shape = builder.EndVector()
        if self.data is not None:
            data = self.data.Pack(builder)
        ConstantNodeStart(builder)
        if self.shape is not None:
            ConstantNodeAddShape(builder, shape)
        ConstantNodeAddDataType(builder, self.dataType)
        if self.data is not None:
            ConstantNodeAddData(builder, data)
        constantNode = ConstantNodeEnd(builder)
        return constantNode


class Dim(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Dim()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsDim(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def DimBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # Dim
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Dim
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # Dim
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def DimStart(builder):
    builder.StartObject(2)

def DimAddValue(builder, value):
    builder.PrependUint32Slot(0, value, 0)

def DimAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def DimEnd(builder):
    return builder.EndObject()



class DimT(object):

    # DimT
    def __init__(self):
        self.value = 0  # type: int
        self.name = None  # type: str

    @classmethod
    def InitFromBuf(cls, buf, pos):
        dim = Dim()
        dim.Init(buf, pos)
        return cls.InitFromObj(dim)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, dim):
        x = DimT()
        x._UnPack(dim)
        return x

    # DimT
    def _UnPack(self, dim):
        if dim is None:
            return
        self.value = dim.Value()
        self.name = dim.Name()

    # DimT
    def Pack(self, builder):
        if self.name is not None:
            name = builder.CreateString(self.name)
        DimStart(builder)
        DimAddValue(builder, self.value)
        if self.name is not None:
            DimAddName(builder, name)
        dim = DimEnd(builder)
        return dim


class ValueNode(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ValueNode()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsValueNode(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ValueNodeBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # ValueNode
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ValueNode
    def Shape(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Dim()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # ValueNode
    def ShapeLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ValueNode
    def ShapeIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

def ValueNodeStart(builder):
    builder.StartObject(1)

def ValueNodeAddShape(builder, shape):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(shape), 0)

def ValueNodeStartShapeVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def ValueNodeEnd(builder):
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class ValueNodeT(object):

    # ValueNodeT
    def __init__(self):
        self.shape = None  # type: List[DimT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        valueNode = ValueNode()
        valueNode.Init(buf, pos)
        return cls.InitFromObj(valueNode)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, valueNode):
        x = ValueNodeT()
        x._UnPack(valueNode)
        return x

    # ValueNodeT
    def _UnPack(self, valueNode):
        if valueNode is None:
            return
        if not valueNode.ShapeIsNone():
            self.shape = []
            for i in range(valueNode.ShapeLength()):
                if valueNode.Shape(i) is None:
                    self.shape.append(None)
                else:
                    dim_ = DimT.InitFromObj(valueNode.Shape(i))
                    self.shape.append(dim_)

    # ValueNodeT
    def Pack(self, builder):
        if self.shape is not None:
            shapelist = []
            for i in range(len(self.shape)):
                shapelist.append(self.shape[i].Pack(builder))
            ValueNodeStartShapeVector(builder, len(self.shape))
            for i in reversed(range(len(self.shape))):
                builder.PrependUOffsetTRelative(shapelist[i])
            shape = builder.EndVector()
        ValueNodeStart(builder)
        if self.shape is not None:
            ValueNodeAddShape(builder, shape)
        valueNode = ValueNodeEnd(builder)
        return valueNode


class Node(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Node()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsNode(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def NodeBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # Node
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Node
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Node
    def DataType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # Node
    def Data(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            from flatbuffers.table import Table
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

def NodeStart(builder):
    builder.StartObject(3)

def NodeAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def NodeAddDataType(builder, dataType):
    builder.PrependUint8Slot(1, dataType, 0)

def NodeAddData(builder, data):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(data), 0)

def NodeEnd(builder):
    return builder.EndObject()


try:
    from typing import Union
except:
    pass

class NodeT(object):

    # NodeT
    def __init__(self):
        self.name = None  # type: str
        self.dataType = 0  # type: int
        self.data = None  # type: Union[None, OperatorNodeT, ConstantNodeT, ValueNodeT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        node = Node()
        node.Init(buf, pos)
        return cls.InitFromObj(node)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, node):
        x = NodeT()
        x._UnPack(node)
        return x

    # NodeT
    def _UnPack(self, node):
        if node is None:
            return
        self.name = node.Name()
        self.dataType = node.DataType()
        self.data = NodeKindCreator(self.dataType, node.Data())

    # NodeT
    def Pack(self, builder):
        if self.name is not None:
            name = builder.CreateString(self.name)
        if self.data is not None:
            data = self.data.Pack(builder)
        NodeStart(builder)
        if self.name is not None:
            NodeAddName(builder, name)
        NodeAddDataType(builder, self.dataType)
        if self.data is not None:
            NodeAddData(builder, data)
        node = NodeEnd(builder)
        return node


class Graph(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Graph()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsGraph(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def GraphBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # Graph
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Graph
    def Nodes(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Node()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Graph
    def NodesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Graph
    def NodesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # Graph
    def Inputs(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Graph
    def InputsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # Graph
    def InputsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Graph
    def InputsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # Graph
    def Outputs(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Graph
    def OutputsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # Graph
    def OutputsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Graph
    def OutputsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

def GraphStart(builder):
    builder.StartObject(3)

def GraphAddNodes(builder, nodes):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(nodes), 0)

def GraphStartNodesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def GraphAddInputs(builder, inputs):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(inputs), 0)

def GraphStartInputsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def GraphAddOutputs(builder, outputs):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(outputs), 0)

def GraphStartOutputsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def GraphEnd(builder):
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class GraphT(object):

    # GraphT
    def __init__(self):
        self.nodes = None  # type: List[NodeT]
        self.inputs = None  # type: List[int]
        self.outputs = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        graph = Graph()
        graph.Init(buf, pos)
        return cls.InitFromObj(graph)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, graph):
        x = GraphT()
        x._UnPack(graph)
        return x

    # GraphT
    def _UnPack(self, graph):
        if graph is None:
            return
        if not graph.NodesIsNone():
            self.nodes = []
            for i in range(graph.NodesLength()):
                if graph.Nodes(i) is None:
                    self.nodes.append(None)
                else:
                    node_ = NodeT.InitFromObj(graph.Nodes(i))
                    self.nodes.append(node_)
        if not graph.InputsIsNone():
            if np is None:
                self.inputs = []
                for i in range(graph.InputsLength()):
                    self.inputs.append(graph.Inputs(i))
            else:
                self.inputs = graph.InputsAsNumpy()
        if not graph.OutputsIsNone():
            if np is None:
                self.outputs = []
                for i in range(graph.OutputsLength()):
                    self.outputs.append(graph.Outputs(i))
            else:
                self.outputs = graph.OutputsAsNumpy()

    # GraphT
    def Pack(self, builder):
        if self.nodes is not None:
            nodeslist = []
            for i in range(len(self.nodes)):
                nodeslist.append(self.nodes[i].Pack(builder))
            GraphStartNodesVector(builder, len(self.nodes))
            for i in reversed(range(len(self.nodes))):
                builder.PrependUOffsetTRelative(nodeslist[i])
            nodes = builder.EndVector()
        if self.inputs is not None:
            if np is not None and type(self.inputs) is np.ndarray:
                inputs = builder.CreateNumpyVector(self.inputs)
            else:
                GraphStartInputsVector(builder, len(self.inputs))
                for i in reversed(range(len(self.inputs))):
                    builder.PrependUint32(self.inputs[i])
                inputs = builder.EndVector()
        if self.outputs is not None:
            if np is not None and type(self.outputs) is np.ndarray:
                outputs = builder.CreateNumpyVector(self.outputs)
            else:
                GraphStartOutputsVector(builder, len(self.outputs))
                for i in reversed(range(len(self.outputs))):
                    builder.PrependUint32(self.outputs[i])
                outputs = builder.EndVector()
        GraphStart(builder)
        if self.nodes is not None:
            GraphAddNodes(builder, nodes)
        if self.inputs is not None:
            GraphAddInputs(builder, inputs)
        if self.outputs is not None:
            GraphAddOutputs(builder, outputs)
        graph = GraphEnd(builder)
        return graph


class Metadata(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Metadata()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMetadata(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def MetadataBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # Metadata
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Metadata
    def OnnxHash(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Metadata
    def Description(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Metadata
    def License(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Metadata
    def Commit(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Metadata
    def CodeRepository(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Metadata
    def ModelRepository(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Metadata
    def RunId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Metadata
    def RunUrl(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def MetadataStart(builder):
    builder.StartObject(8)

def MetadataAddOnnxHash(builder, onnxHash):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(onnxHash), 0)

def MetadataAddDescription(builder, description):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(description), 0)

def MetadataAddLicense(builder, license):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(license), 0)

def MetadataAddCommit(builder, commit):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(commit), 0)

def MetadataAddCodeRepository(builder, codeRepository):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(codeRepository), 0)

def MetadataAddModelRepository(builder, modelRepository):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(modelRepository), 0)

def MetadataAddRunId(builder, runId):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(runId), 0)

def MetadataAddRunUrl(builder, runUrl):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(runUrl), 0)

def MetadataEnd(builder):
    return builder.EndObject()



class MetadataT(object):

    # MetadataT
    def __init__(self):
        self.onnxHash = None  # type: str
        self.description = None  # type: str
        self.license = None  # type: str
        self.commit = None  # type: str
        self.codeRepository = None  # type: str
        self.modelRepository = None  # type: str
        self.runId = None  # type: str
        self.runUrl = None  # type: str

    @classmethod
    def InitFromBuf(cls, buf, pos):
        metadata = Metadata()
        metadata.Init(buf, pos)
        return cls.InitFromObj(metadata)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, metadata):
        x = MetadataT()
        x._UnPack(metadata)
        return x

    # MetadataT
    def _UnPack(self, metadata):
        if metadata is None:
            return
        self.onnxHash = metadata.OnnxHash()
        self.description = metadata.Description()
        self.license = metadata.License()
        self.commit = metadata.Commit()
        self.codeRepository = metadata.CodeRepository()
        self.modelRepository = metadata.ModelRepository()
        self.runId = metadata.RunId()
        self.runUrl = metadata.RunUrl()

    # MetadataT
    def Pack(self, builder):
        if self.onnxHash is not None:
            onnxHash = builder.CreateString(self.onnxHash)
        if self.description is not None:
            description = builder.CreateString(self.description)
        if self.license is not None:
            license = builder.CreateString(self.license)
        if self.commit is not None:
            commit = builder.CreateString(self.commit)
        if self.codeRepository is not None:
            codeRepository = builder.CreateString(self.codeRepository)
        if self.modelRepository is not None:
            modelRepository = builder.CreateString(self.modelRepository)
        if self.runId is not None:
            runId = builder.CreateString(self.runId)
        if self.runUrl is not None:
            runUrl = builder.CreateString(self.runUrl)
        MetadataStart(builder)
        if self.onnxHash is not None:
            MetadataAddOnnxHash(builder, onnxHash)
        if self.description is not None:
            MetadataAddDescription(builder, description)
        if self.license is not None:
            MetadataAddLicense(builder, license)
        if self.commit is not None:
            MetadataAddCommit(builder, commit)
        if self.codeRepository is not None:
            MetadataAddCodeRepository(builder, codeRepository)
        if self.modelRepository is not None:
            MetadataAddModelRepository(builder, modelRepository)
        if self.runId is not None:
            MetadataAddRunId(builder, runId)
        if self.runUrl is not None:
            MetadataAddRunUrl(builder, runUrl)
        metadata = MetadataEnd(builder)
        return metadata


class Model(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Model()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsModel(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ModelBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x52\x54\x45\x4E", size_prefixed=size_prefixed)

    # Model
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Model
    def SchemaVersion(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Model
    def Graph(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Graph()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Model
    def Metadata(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Metadata()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

def ModelStart(builder):
    builder.StartObject(3)

def ModelAddSchemaVersion(builder, schemaVersion):
    builder.PrependInt32Slot(0, schemaVersion, 0)

def ModelAddGraph(builder, graph):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(graph), 0)

def ModelAddMetadata(builder, metadata):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(metadata), 0)

def ModelEnd(builder):
    return builder.EndObject()


try:
    from typing import Optional
except:
    pass

class ModelT(object):

    # ModelT
    def __init__(self):
        self.schemaVersion = 0  # type: int
        self.graph = None  # type: Optional[GraphT]
        self.metadata = None  # type: Optional[MetadataT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        model = Model()
        model.Init(buf, pos)
        return cls.InitFromObj(model)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, model):
        x = ModelT()
        x._UnPack(model)
        return x

    # ModelT
    def _UnPack(self, model):
        if model is None:
            return
        self.schemaVersion = model.SchemaVersion()
        if model.Graph() is not None:
            self.graph = GraphT.InitFromObj(model.Graph())
        if model.Metadata() is not None:
            self.metadata = MetadataT.InitFromObj(model.Metadata())

    # ModelT
    def Pack(self, builder):
        if self.graph is not None:
            graph = self.graph.Pack(builder)
        if self.metadata is not None:
            metadata = self.metadata.Pack(builder)
        ModelStart(builder)
        ModelAddSchemaVersion(builder, self.schemaVersion)
        if self.graph is not None:
            ModelAddGraph(builder, graph)
        if self.metadata is not None:
            ModelAddMetadata(builder, metadata)
        model = ModelEnd(builder)
        return model
