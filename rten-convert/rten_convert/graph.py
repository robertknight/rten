"""Types used in intermediate representation of parsed ONNX graphs.

This module defines graph and node types produced by parsing ONNX files. These
are in a format that is convenient for serialization into the FlatBuffers
format used by .rten models.
"""

from typing import Any

import numpy as np

from rten_convert.errors import ConversionError
from rten_convert.util import warn_once


class Node:
    """Base class for all graph nodes (constants, values, operators)."""

    def __init__(self, name: str):
        self.name = name


class ConstantNode(Node):
    """
    Data for a constant graph node.

    These are used for model weights, biases etc.
    """

    shape: list[int]
    data: np.ndarray

    def __init__(self, name: str, shape: list[int], data: np.ndarray):
        super().__init__(name)
        self.shape = shape
        self.data = data

        shape_numel = np.prod(shape)
        if shape_numel != data.size:
            raise ConversionError(
                f'Shape {shape} product {shape_numel} does not match data length {data.size} in node "{name}"'
            )

        # Verify that this is a data type that we'll be able to serialize later.
        match data.dtype:
            case np.float32 | np.int32 | np.int8 | np.uint8:
                pass
            case _:
                dtype_name: str = data.dtype.name  # type:ignore[union-attr]
                raise ConversionError(
                    f'Tried to construct ConstantNode "{name}" with unsupported data type {dtype_name}'
                )

    def get_scalar(self):
        if self.shape != []:
            return None
        return self.data[0]


class OperatorNode(Node):
    """
    Data for an operator graph node.
    """

    # RTen operator name. This should match the operator name in the FlatBuffers
    # schema.
    op_type: str

    attrs: Any
    """
    Attributes object or None.

    This should be the operator-specific attributes object generated by flatc.
    eg. `sg.AveragePoolAttrsT` for the AveragePool op.
    """

    inputs: list[int | None]
    outputs: list[int | None]

    def __init__(
        self,
        name: str,
        op_type: str,
        attrs: Any,
        inputs: list[int | None],
        outputs: list[int | None],
    ):
        super().__init__(name)
        self.op_type = op_type
        self.attrs = attrs
        self.inputs = inputs
        self.outputs = outputs


class ValueNode(Node):
    """
    Data for a value placeholder graph node.

    These are used for operator inputs and outputs.

    The shape can be missing, or a mix of fixed and symbolic (unknown at model
    export time) sizes.
    """

    def __init__(self, name: str, shape: list[int | str] | None, dtype: int | None):
        """
        Initialize a value node.

        :param name: Unique name of the value
        :param shape: Expected shape of tensor at runtime
        :param dtype: Expected data type of tensor at runtime. Value from `sg.DataType`.
        """
        super().__init__(name)

        if shape is not None:
            # RTen models can only store unsigned ints in shape metadata, so
            # discard any invalid negative values.
            for i, size_or_name in enumerate(shape):
                if isinstance(size_or_name, int) and size_or_name < 0:
                    warn_once(
                        "shape metadata for {} contains invalid size {}",
                        name,
                        size_or_name,
                    )
                    shape[i] = "unknown"

        self.shape = shape
        self.dtype = dtype


class Graph:
    nodes: list[Node]

    inputs: list[int]
    """Indices of nodes in `nodes` that are model inputs."""

    outputs: list[int]
    """Indices of nodes in `nodes` that are model outputs."""

    captures: list[int] | None
    """Indices of nodes in `nodes` that are captured from parent scopes at runtime."""

    def __init__(
        self,
        nodes: list[Node],
        inputs: list[int],
        outputs: list[int],
        captures: list[int] | None = None,
    ):
        self.nodes = nodes
        self.inputs = inputs
        self.outputs = outputs
        self.captures = captures
